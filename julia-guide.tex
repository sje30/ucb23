% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrreprt}

\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else  
    % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\setcounter{secnumdepth}{5}
% Make \paragraph and \subparagraph free-standing
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\newlength{\cslhangindent}
\setlength{\cslhangindent}{1.5em}
\newlength{\csllabelwidth}
\setlength{\csllabelwidth}{3em}
\newlength{\cslentryspacingunit} % times entry-spacing
\setlength{\cslentryspacingunit}{\parskip}
\newenvironment{CSLReferences}[2] % #1 hanging-ident, #2 entry spacing
 {% don't indent paragraphs
  \setlength{\parindent}{0pt}
  % turn on hanging indent if param 1 is 1
  \ifodd #1
  \let\oldpar\par
  \def\par{\hangindent=\cslhangindent\oldpar}
  \fi
  % set entry spacing
  \setlength{\parskip}{#2\cslentryspacingunit}
 }%
 {}
\usepackage{calc}
\newcommand{\CSLBlock}[1]{#1\hfill\break}
\newcommand{\CSLLeftMargin}[1]{\parbox[t]{\csllabelwidth}{#1}}
\newcommand{\CSLRightInline}[1]{\parbox[t]{\linewidth - \csllabelwidth}{#1}\break}
\newcommand{\CSLIndent}[1]{\hspace{\cslhangindent}#1}

\KOMAoption{captions}{tableheading}
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\@ifpackageloaded{fontawesome5}{}{\usepackage{fontawesome5}}
\definecolor{quarto-callout-color}{HTML}{909090}
\definecolor{quarto-callout-note-color}{HTML}{0758E5}
\definecolor{quarto-callout-important-color}{HTML}{CC1914}
\definecolor{quarto-callout-warning-color}{HTML}{EB9113}
\definecolor{quarto-callout-tip-color}{HTML}{00A047}
\definecolor{quarto-callout-caution-color}{HTML}{FC5300}
\definecolor{quarto-callout-color-frame}{HTML}{acacac}
\definecolor{quarto-callout-note-color-frame}{HTML}{4582ec}
\definecolor{quarto-callout-important-color-frame}{HTML}{d9534f}
\definecolor{quarto-callout-warning-color-frame}{HTML}{f0ad4e}
\definecolor{quarto-callout-tip-color-frame}{HTML}{02b875}
\definecolor{quarto-callout-caution-color-frame}{HTML}{fd7e14}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\makeatother
\makeatletter
\@ifundefined{shadecolor}{\definecolor{shadecolor}{rgb}{.97, .97, .97}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\makeatother
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={Julia Guide},
  pdfauthor={James Byrne},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}

\title{Julia Guide}
\author{James Byrne}
\date{2023-07-04}

\begin{document}
\maketitle
\ifdefined\Shaded\renewenvironment{Shaded}{\begin{tcolorbox}[enhanced, breakable, interior hidden, borderline west={3pt}{0pt}{shadecolor}, boxrule=0pt, frame hidden, sharp corners]}{\end{tcolorbox}}\fi

\renewcommand*\contentsname{Table of contents}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}
\bookmarksetup{startatroot}

\hypertarget{about}{%
\chapter*{About}\label{about}}
\addcontentsline{toc}{chapter}{About}

\markboth{About}{About}

This is a guide to using Julia. Use the sidebars on the left and right
to navigate between the pages.

To get started, you can try the demonstration version of Julia on the
official Julia website at
\url{https://julialang.org/learning/tryjulia/}. Click the play button,
and you should be greeted with the \texttt{julia\textgreater{}} prompt.
If you can see that, then you're ready to go!

If you'd like to jump straight to trying some programming, you can skip
forward to Chapter~\ref{sec-fundamentals}. Note however, this is limited
by being a web-hosted system, and for most uses of Julia it will be
insufficient. What's more, it won't allow you to save files, which is
something we'll want to do eventually to avoid typing out a long
sequence of commands every time we want to do a computation. Instead,
you'll eventually want to install Julia for yourself, for which guidance
is given in Chapter~\ref{sec-installation}.

\bookmarksetup{startatroot}

\hypertarget{credits}{%
\chapter*{Credits}\label{credits}}
\addcontentsline{toc}{chapter}{Credits}

\markboth{Credits}{Credits}

This project was funded by the
\href{https://www.cambridge.org/}{Cambridge University Press}.

This book was rendered by \href{https://quarto.org/}{Quarto}.

Licence: \href{https://creativecommons.org/licenses/by-nc-sa/2.0/}{CC
BY-NC-SA}

\bookmarksetup{startatroot}

\hypertarget{sec-installation}{%
\chapter{Installation and general usage}\label{sec-installation}}

\hypertarget{installing-julia}{%
\section{Installing Julia}\label{installing-julia}}

The Julia program can be downloaded from
\url{https://julialang.org/downloads/}. You'll need to choose the
correct version for your system, with different instructions for
installation for different systems found at
\url{https://julialang.org/downloads/platform/}. It will be important to
\emph{Add Julia to PATH}, which you will see mentioned in these
instructions, as we'll want to make Julia findable for our editor in a
moment.

Once the program is installed, you can launch it, and begin to type (for
example, some basic sums like \texttt{1\ +\ 2}). This input is called
the \emph{REPL} or \emph{read-eval-print loop}, because what it does is
the following:

\begin{itemize}
\item
  It reads what the user has typed in
\item
  It attempts to evaluate it as Julia code
\item
  It prints the result of the evaluation, whether that is a calculation
  result, or a message telling the user that something has gone wrong
\item
  It loops back around to the start, putting the
  \texttt{julia\textgreater{}} prompt again and waiting for another user
  input
\end{itemize}

The REPL has all the functionality of Julia, and more. Previous inputs
can be navigated to by \texttt{↑} and \texttt{↓}, or searched with the
search modes (accessible through \texttt{Ctrl}-\texttt{S} /
\texttt{Cmd}-\texttt{S} and \texttt{Ctrl}-\texttt{R} /
\texttt{Cmd}-\texttt{R}). Help can be found by pressing \texttt{?} to
enter help mode, while package mode comes from typing \texttt{;}.

However, it still has one major limitation, which is that nothing is
saved. If you close the program and reopen it, you'll notice that it has
no memory of any of the computations it has done before. Once we start
chaining computations together into fully fledged algorithms, we don't
want to lose all of our progress every time we close the program, nor do
we want to leave it running the whole time taking up unnecessary memory.
For this, we'll need to make use of our own files, saved on our
computer, with our code written out in full contained within it. This is
entirely possible to do within the REPL, but for most people is
needlessly difficult, so we'll make use of a code editor, specifically
an \emph{integrated development environment}, or \emph{IDE} for short.

An IDE does many things, with different ones having different
attractions. The most common features include:

\begin{itemize}
\item
  Code editor, for writing and editing code files, which can be saved to
  the computer
\item
  Syntax highlighting, by changing the colour and sometimes other
  aspects of the font to distinguish keywords, or sections of the code
  file that do different things
\item
  Automatic indentation, which for Julia is not needed in general, but
  helps for readability of code to show where blocks of code start and
  end
\item
  Debugging tools, such as recognising errors in code before it is run
\item
  Integrated terminal/REPL, so code can be run and tested quickly and
  easily
\end{itemize}

There are many IDEs in existence, but the most popular for Julia is
\emph{VS Code}, which we'll focus on here.

\hypertarget{installing-vscode}{%
\section{Installing VSCode}\label{installing-vscode}}

Microsoft's VSCode is an IDE with compatibility with hundreds if not
thousands of programming languages, and more beyond that. However, we'll
only look at its use for Julia.

To begin with, VSCode will need to be downloaded from
\url{https://code.visualstudio.com/download/}, where you'll need to
choose the right version for your system as you did with Julia. Once
it's installed, you'll need to open it, and install the Julia extension,
which allows VSCode to work with Julia. This can be done by finding the
extensions tab on the left sidebar (which looks like three squares in an
L shape with a fourth floating above), and searching for Julia in the
search box. Now, if you've installed this, and if you clicked \emph{Add
Julia to PATH} earlier, then everything should be set up to start
programming. If not, the documentation at
\url{https://www.julia-vscode.org/docs/dev/} should help to resolve your
issue.

\hypertarget{using-julia-in-vscode}{%
\section{Using Julia in VSCode}\label{using-julia-in-vscode}}

To open an instance of the Julia REPL in VSCode, hold down the
\texttt{Alt} key, and press \texttt{J} followed by \texttt{O}. This
functions identically to the REPL that appears when we open the Julia
program.

In VSCode, we can also open a \texttt{.jl} file to be able to write code
and save it to be run whenever we wish, as well as to be able to be run
from within other programs. This is essential for larger projects, and
can be done by going to \texttt{File\ -\ New\ File}, and choosing
``Julia File''. Alternatively, holding down \texttt{Alt} and pressing
\texttt{J} followed by \texttt{N} has the same effect. You can save this
file as a Julia \texttt{.jl} file, and any code written in it can be run
by the play button in the top right corner of the editor window.

VSCode is highly customisable, and you are recommended to experimented
with its many options to find the layouts and functionalities that work
best for you.

\hypertarget{pluto-notebooks}{%
\section{Pluto notebooks}\label{pluto-notebooks}}

A third alternative working environment is provided by the Pluto
notebook, from the \texttt{Pluto.jl} package. For this, you'll need to
install Julia as before, but you don't need an IDE.

First, launch the Julia program, giving an instance of the REPL. Next,
press \texttt{{]}} to enter \texttt{Pkg} mode, type \texttt{add\ Pluto},
and press \texttt{Enter\ ⮠} which will download and install the package.
Once that is done, press \texttt{←\ Backspace} to return to the normal
REPL mode, type \texttt{using\ Pluto}, and press \texttt{Enter\ ⮠},
which tells Julia to load the package ready for use. Finally, type
\texttt{Pluto.run()} and press \texttt{Enter\ ⮠}, which will launch
Pluto in your default web browser.

Pluto works markedly differently from the REPL and editor environments,
and is perhaps best explained by the \emph{Getting Started} notebooks on
its homepage.

When using Pluto for a second time, you don't need to install it again,
just launch the REPL fresh and start at \texttt{using\ Pluto}.

More in depth discussion of using packages in general can be found in
Chapter~\ref{sec-packages}.

\part{The basics of Julia}

In this section, we'll examine the basic building blocks of Julia, and
of programming in general, and see how we can harness them to maximal
effect.

\begin{itemize}
\item
  Chapter~\ref{sec-fundamentals} begins by looking at the building
  blocks of Julia programming, in particular \emph{variables},
  \emph{functions}, and \emph{types}. We also see how Julia itself can
  help us if we make a mistake or get stuck
\item
  Chapter~\ref{sec-numerictypes} dives down into the different ways that
  numbers can be represented in Julia, their pros and cons, as well as
  the potential arithmetic errors that we need to be aware of when using
  them
\item
  Chapter~\ref{sec-strings} instead shows how text is represented in
  Julia using the \texttt{String} type, and how they can be manipulated
\item
  Chapter~\ref{sec-controlflow} discusses the different methods of
  manipulating code to run in more ways than just line by line down the
  page, and the possibilities that this brings
\item
  Chapter~\ref{sec-customstructures} looks again at \emph{variables},
  \emph{functions}, and \emph{types}, and how we can create our own
  custom structures of these forms
\item
  Chapter~\ref{sec-multipledispatch} analyses the key paradigm of Julia
  that is \emph{multiple dispatch}, how it works, why we would use it,
  and how to make use of it ourselves
\item
  Chapter~\ref{sec-packages} breaks down the packaging system of Julia,
  which permits the installation and use of specialised code written by
  others to add functionality
\item
  Chapter~\ref{sec-arrays} investigates ways to store and manipulate
  several pieces of data in one go. We see how Julia works intelligently
  with such collections, meet some of the specialised types that take
  such a form, as well as putting this to use in plotting Julia sets
\item
  Chapter~\ref{sec-readwrite} demonstrates Julia's ability to read and
  write data from or to external files
\item
  Chapter~\ref{sec-plotting} describes how to use the \texttt{Plots.jl}
  package to plot data as a graph
\item
  Chapter~\ref{sec-testing} introduces ways of testing code
\end{itemize}

These chapters will refer to each other in places, but may be read
somewhat independently of each other. At the start of each chapter, a
list of recommended prerequisites is given.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Convention}, colframe=quarto-callout-tip-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

As with all programming languages, Julia has many conventions of naming,
syntax, and style (and these can differ from other languages!), which
will be highlighted in boxes like this. These range from the
inconsequential mundanities to the genuine good practice stopping you
from breaking something important, but beginners should strive to follow
them as much as possible nonetheless.

\end{tcolorbox}

\hypertarget{sec-fundamentals}{%
\chapter{Fundamental concepts}\label{sec-fundamentals}}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-important-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Prerequisites}, colframe=quarto-callout-important-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

This chapter has no prerequisites

\end{tcolorbox}

\hypertarget{printing-and-calculating}{%
\section{Printing and calculating}\label{printing-and-calculating}}

Now that we've got Julia up and running, let's see what it can do. In
time-honoured fashion, we'll begin by getting Julia to say
\texttt{Hello\ world!} to us. In the REPL, this is as simple as
enclosing the text in double quotation marks \texttt{"\ "} (making it a
\emph{string}, which Julia knows not to try and evaluate as code), and
pressing \texttt{Enter\ ⮠}:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"Hello world!"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"Hello world!"
\end{verbatim}

To get rid of the quotation marks around the output, we can use the
keyword \texttt{print}, and enclose our phrase in parentheses
\texttt{()} immediately after (without a space):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(}\StringTok{"Hello world!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hello world!
\end{verbatim}

A relatively unique feature of Julia is the ability to use a wider range
of characters in code than just the normal \texttt{A-Z}, \texttt{a-z},
\texttt{0-9} and common punctuation. So let's update
\texttt{Hello\ world!} to the 21st century:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(}\StringTok{"👋🌍❗"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
👋🌍❗
\end{verbatim}

These emoji can be copied in from elsewhere, but the Julia REPL as well
as environments such as VSCode in a \texttt{.jl} file or a Pluto
notebook allow \emph{tab-completion} to type such symbols. If you know
the right code for the symbol you want (which will always begin with a
backslash \texttt{\textbackslash{}}), typing out the name and pressing
\texttt{Tab\ ⇆} will give the symbol. For instance, the three emoji used
here have codes \texttt{\textbackslash{}:wave:} for 👋,
\texttt{\textbackslash{}:earth\_africa:} for 🌍, and
\texttt{\textbackslash{}:exclamation:} for❗.

What else can we type? We can get Julia to do some basic sums, using the
symbols \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\^{}} as
add, subtract, multiply, divide, and exponentiate respectively, with
parentheses \texttt{()} used to prioritise operations as usual, and
otherwise the normal order of operations is assumed:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{1} \OperatorTok{+} \FloatTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{7}\OperatorTok{*}\FloatTok{8}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
56
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{5} \OperatorTok{+}\NormalTok{ (}\FloatTok{3} \OperatorTok{{-}} \FloatTok{1}\OperatorTok{/}\FloatTok{2}\NormalTok{) }\OperatorTok{*} \FloatTok{20}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
55.0
\end{verbatim}

We also see here the use of a \emph{comment}. Anything in the same line
following a hash \texttt{\#} will be ignored by Julia, so we can write
some explanation next to our code to help us remember what it is
supposed to do.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Convention}, colframe=quarto-callout-tip-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Adding comments isn't particularly useful in the REPL (especially as it
is forgotten after the REPL is closed), but in \texttt{.jl} script files
it is highly recommended, particularly the longer and more complex a
program gets.

\end{tcolorbox}

Julia is far more that a glorified calculator, however. We'll start be
seeing how we can save data for later, using \emph{variables}.

\hypertarget{variables}{%
\section{Variables}\label{variables}}

Variables are a way to give a data a name, which we can use to refer to
that data later. This allows us to write code that performs calculations
where we don't explicitly tell Julia which numbers to use. A value is
assigned to a variable using \texttt{=} as follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number1 }\OperatorTok{=} \FloatTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

Names of variables are important to choose carefully. We have a
multitude of such characters at our disposal, including non-Latin
scripts, and emoji like we've seen before in text form (although we are
somewhat limited for the first character, which must be a letter or
letter-like symbol, e.g not a number). They must also not conflict with
any of Julia's inbuilt keywords, such as \texttt{print} we've seen
above, or words like \texttt{if}, \texttt{for}, \texttt{end} that we'll
see in later chapters. Most punctuation characters (except \texttt{\_})
are also not allowed, as they have other purposes, such as \texttt{"\ "}
for enclosing text and \texttt{\#} for comments as we've already seen.
Moreover, Julia is case-sensitive, so \texttt{X} and \texttt{x} would
refer to different things.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Convention}, colframe=quarto-callout-tip-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Names of variables should be in lowercase, with no spaces (as the space
marks the end of the variable name) or underscores (unless they are
needed to make the name readable).

\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{αριθμός}\FloatTok{2}\NormalTok{️⃣ }\OperatorTok{=} \FloatTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
\end{verbatim}

We can ask Julia to tell us the value of the variable simply by typing
the name of that variable.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

We can then use the names in place of the values they represent in sums.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number1 }\OperatorTok{+}\NormalTok{ αριθμός}\FloatTok{2}\NormalTok{️⃣}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

The value of a variable can be changed by the same means that we gave it
a value in the first place.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number1 }\OperatorTok{=} \StringTok{"one"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"one"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"one"
\end{verbatim}

There are many more uses for variables than just saving data for later,
but for now we'll move on to look at the reason that Julia already uses
many names, which is to refer to its many inbuilt \emph{functions}.

\hypertarget{functions}{%
\section{Functions}\label{functions}}

A function, at its simplest, is a way of performing a predetermined
algorithm or calculation without having to laboriously do each step one
at a time yourself. Instead, it is known only by its name, and Julia
understands references to its name as requests to perform said
algorithm. For example, we can use Julia to calculate square roots using
the \texttt{sqrt} function, even if we don't know the ins and out of the
calculation needed to do it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sqrt}\NormalTok{(}\FloatTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1.4142135623730951
\end{verbatim}

Or, we can find the position of the first letter \texttt{t} in a
sentence:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{findfirst}\NormalTok{(}\CharTok{\textquotesingle{}t\textquotesingle{}}\NormalTok{, }\StringTok{"Shall I compare thee to a summer\textquotesingle{}s day?"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
17
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-warning-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Warning}, colframe=quarto-callout-warning-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

The use of single quotation marks
\texttt{\textquotesingle{}t\textquotesingle{}} instead of double
\texttt{"t"} is deliberate here, as they mean different things.

\end{tcolorbox}

The way to input data into a function is to write the function name, and
follow it with a set of parentheses containing the function arguments,
which can be literals (that is, writing the data in literally), or
variables (where the value of the variable will be given to the
function). If there are multiple inputs, they will need to be separated
by commas, such as in the \texttt{min} function which finds the minimum
of its inputs:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{min}\NormalTok{(}\FloatTok{1}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{, }\FloatTok{4}\NormalTok{, }\FloatTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

Indeed, we've already met several functions above without even knowing
it. \texttt{print} is a function that takes an input and prints the
result in the REPL. Although they might not look like it, the
mathematical operations are also functions, with the special
\emph{infix} (putting the function name between two arguments) notation
used since that's what we're used to. It is entirely possible to write
such calculations in the standard function format, and they work just
the same:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{+}\NormalTok{(}\FloatTok{1}\NormalTok{, }\FloatTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

Not only that, but it's possible to write our own functions to
encapsulate bits of code that we want to run again and again, perhaps
with different starting values. We'll see how to do this in
Chapter~\ref{sec-customstructures}.

Functions won't always give an answer, though. Often, this is because
the input is nonsensical for what the function is supposed to be doing,
such as:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sqrt}\NormalTok{(}\StringTok{"cabbage"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Running this will give an \emph{exception} (alternatively called an
\emph{error}), which far from being a bad thing, can help us to track
down and fix problems in our code. In this case, the problem is as
simple as the fact that Julia doesn't know how to take the square root
of a string of text. This brings us on to looking at the \emph{types} of
data that Julia can handle.

\hypertarget{types}{%
\section{Types}\label{types}}

Every piece of data that you give Julia, be it a number, a string of
text, a collection of elements, even a block of Julia code, has along
with it a label that tells Julia how to interpret it. This is called the
type of the data, and we've seen many already:

\begin{itemize}
\item
  Text enclosed in double quotation marks \texttt{"\ "} has type
  \texttt{String}, meant for representing data in the form of text
\item
  Individual symbols enclosed in single quotation marks
  \texttt{\textquotesingle{}\ \textquotesingle{}} have type
  \texttt{Char}, short for character. This is a simpler format than
  \texttt{String}, being more intrinsically understood by the computer,
  in fact \texttt{String}s are little more than sequences of
  \texttt{Char}s
\item
  Numbers have types, although there are many different types for
  different numbers. Common ones include \texttt{Int64} for integers and
  \texttt{Float64} for decimals. For further discussion of this, see
  Chapter~\ref{sec-numerictypes}
\item
  Functions also have types, although they are slightly more
  complicated. We can use the \texttt{typeof} function to query types,
  and as we can see, the \texttt{sqrt} function has type
  \texttt{typeof(sqrt)}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(sqrt)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
typeof(sqrt) (singleton type of function sqrt, subtype of Function)
\end{verbatim}

As the bizarre result above suggests, types have many intricacies to
them. They are related by the \emph{type graph}, which groups together
types in various categories as a tree structure. We'll see examples of
this in Chapter~\ref{sec-numerictypes} and Chapter~\ref{sec-arrays}, and
dive into the details in Chapter~\ref{sec-multipledispatch}. We can also
define our own types, as we'll see in
Chapter~\ref{sec-customstructures}. For now, we'll just think of them as
a way for Julia to distinguish what sort of data we give it, and how it
should be processed and stored.

\hypertarget{help-functionality}{%
\section{Help functionality}\label{help-functionality}}

Whether you're just getting started, or are very experienced, it can
sometimes be difficult to fix problems or remember how certain functions
work. For this purpose, Julia has a number of ways to provide guidance
to put you back on track.

\hypertarget{tab-completion}{%
\subsection{Tab completion}\label{tab-completion}}

We've already seen tab-completion to type non-standard characters, like
emoji. In fact, tab-completion does more than this, it can complete
(hence the name) partially typed keywords or variable names. For
example, typing \texttt{sq} in the REPL and then pressing
\texttt{Tab\ ⇆} gives the word \texttt{sqrt}, as it is the only keyword
that Julia knows beginning with \texttt{sqrt}. However, if we define a
variable:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{squid }\OperatorTok{=} \StringTok{"🦑"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"🦑"
\end{verbatim}

then pressing \texttt{Tab\ ⇆} once doesn't do anything, because it
doesn't know which one of \texttt{sqrt} and \texttt{squid} we want.
Pressing \texttt{Tab\ ⇆} again won't complete it, but it will give us a
list of the possibilites that we might mean, so that we can work out
which we meant.

If there are multiple options, but they all share some characters, Julia
will complete as much as possible, e.g.~typing \texttt{prin} and
pressing \texttt{Tab\ ⇆} will give \texttt{print}, as the possible
options are \texttt{print}, \texttt{println}, and \texttt{printstyled},
all of which have \texttt{t} as the next letter.

This can be very useful if you can't remember the exact name of a
variable or function, or just if you're exploring what functions exist
inbuilt into Julia. Other environments than the REPL like the VSCode
editor or Pluto will provide similar tab-completion functionality.

\hypertarget{help-in-the-repl}{%
\subsection{\texorpdfstring{\texttt{help?} in the
REPL}{help? in the REPL}}\label{help-in-the-repl}}

Pressing \texttt{?} in the REPL changes the prompt from the green
\texttt{julia\textgreater{}} to the yellow \texttt{help?\textgreater{}},
entering \emph{help mode}. The functionality of the REPL now changes
dramatically, from executing inputs as code, to giving information about
the keywords and functions used. For example, if we want to learn more
about the function \texttt{+}, we can enter help mode and type
\texttt{+}, or some code including \texttt{+} such as \texttt{2\ +\ 3}.
This gives the following result:

\begin{verbatim}
help?> 2 + 3
  +(x, y...)

  Addition operator. x+y+z+... calls this function with all
  arguments, i.e. +(x, y, z, ...).

  Examples
  ≡≡≡≡≡≡≡≡≡≡

  julia> 1 + 20 + 4
  25
  
  julia> +(1, 20, 4)
  25
\end{verbatim}

Help mode can also give similar names that it knows if you've mistyped
the input:

\begin{verbatim}
help?> min
search: min minmax minimum minimum! argmin Main typemin findmin
\end{verbatim}

Pasting in a Unicode symbol will give you the code to tab-complete and
type the symbol (if a code exists for that symbol):

\begin{verbatim}
help?> 🍄
"🍄" can be typed by \:mushroom:<tab>
\end{verbatim}

To exit help mode, you can press \texttt{←\ Backspace} on an empty line.

\hypertarget{error-messages}{%
\subsection{Error messages}\label{error-messages}}

When an exception occurs, Julia provides an error message, which
although a little intimidating at first with the red \texttt{ERROR:}
text, but actually is very useful in diagnosing issues.

Firstly, the type of error is given, which can tell you immediately what
the problem is in simple cases. For instance, a \texttt{MethodError} may
occur when the inputs to a function have the wrong types, or an
\texttt{UndefVarError} if a word is used that isn't recognised as a
variable name. In the REPL, this can often be enough to find the
mistake, but in more complex programs, with custom functions and
modules, it may not suffice.

Instead, we look to the \texttt{Stacktrace} section. It provides a list
of all of the functions that have been called, with the error occurring
in the first function listed, which itself was called by the second
function listed, and so on. Line numbers are also provided, so if
unexpected behaviour is happening, it can be traced down exactly to the
line or lines of code that caused it.

We'll look more into the ways that exceptions can be used to aid
programming in Chapter~\ref{sec-testing}.

\hypertarget{sec-numerictypes}{%
\chapter{Different numeric types}\label{sec-numerictypes}}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-important-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Prerequisites}, colframe=quarto-callout-important-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Before reading this chapter, you are recommended to have read
Chapter~\ref{sec-fundamentals}

\end{tcolorbox}

Numbers are ubiquitous in Julia programming, as well as in programming
in general. Almost every programmer has at some early point in their
learning set \texttt{a} to be \texttt{1}, \texttt{b} to be \texttt{2},
and added them together. Every operation that a computer does can be
reduced down to a basic arithmetic operation called a logic gate.
Indeed, numbers are so intrinsic to Julia that they are one of the few
things to be part of the \texttt{Core}.

However, all is not as it may seem on the surface. When calculating with
numbers in Julia, it's only a matter of time before you run into some
unexpected results, such as:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{0.1} \OperatorTok{+} \FloatTok{0.2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.30000000000000004
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{2}\OperatorTok{\^{}}\FloatTok{100}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cos}\NormalTok{(}\ConstantTok{π}\NormalTok{) }\CommentTok{\# Julia can calculate this accurately...}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
-1.0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cos}\NormalTok{(}\ConstantTok{π}\OperatorTok{/}\FloatTok{2}\NormalTok{) }\CommentTok{\# ...but not this?}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6.123233995736766e-17
\end{verbatim}

These examples (and many others) demonstrate that the way that computers
calculate is not quite the same as we are used to. Much of this is to do
with the \emph{type} of the numbers in question.

\hypertarget{overview-of-types}{%
\section{Overview of types}\label{overview-of-types}}

We've already met types earlier, but here's a quick refresher. All data
within Julia, including every variable, every literal (that is, data
given as a specific value, like \texttt{22}, rather than a variable name
referring to a value, like \texttt{x}), even every bit of code, has a
type, which does several things:

\begin{itemize}
\item
  It tells Julia how to store the data in the computer's memory
\item
  It tells Julia how to read the value from the computer's memory
\item
  It tells Julia how to react when the data is operated on or passed to
  a function (which we call \emph{multiple dispatch})
\end{itemize}

Combined together, Julia is able to work out what to do with data before
knowing the exact value of the data (much like you know how to use a pen
regardless of what colour it is). This is very flexible for programmers,
and very efficient for computation.

Types are arranged into the \emph{type graph}, which is better described
as a tree structure, with every type given a \emph{parent type} or
\emph{supertype}. Mostly, these parent types are \emph{abstract},
meaning that they can't exist as data themselves, but serve as a label
to refer to any and all of the types below them. The opposite of an
abstract type is a \emph{concrete} type, which is a type that data can
take. (There is a third option, the \emph{parametric} type, which we'll
meet later). The presence of abstract types can be very useful for
multiple dispatch, allowing a function to be written to apply to several
different type inputs at the same time.

To get a bit of a better idea of this structure, we'll look at all of
the different types that come under the abstract type \texttt{Number} by
default in Julia:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Useful for convenient broadcasting in the arrange function}
\ImportTok{import} \BuiltInTok{Base.+}
\FunctionTok{+}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Any}\NormalTok{,}\OperatorTok{::}\DataTypeTok{Nothing}\NormalTok{) }\OperatorTok{=}\NormalTok{ x}

\CommentTok{\# Arranges the subtype tree of T with positions of each of the subtypes}
\CommentTok{\# Format of output is a vector of tuples of the form:}
\CommentTok{\#     (type, number of nodes below, depth, position from top)}
\KeywordTok{function} \FunctionTok{arrange}\NormalTok{(T}\OperatorTok{::}\DataTypeTok{Type}\NormalTok{)}

    \CommentTok{\# Deals with small cases, where a type is not defined in Base we ignore it}
    \FunctionTok{isdefined}\NormalTok{(}\BuiltInTok{Base}\NormalTok{, }\FunctionTok{Symbol}\NormalTok{(T)) }\OperatorTok{||} \ControlFlowTok{return} \DataTypeTok{Tuple}\NormalTok{\{}\DataTypeTok{Type}\NormalTok{, }\DataTypeTok{Int64}\NormalTok{, }\DataTypeTok{Int64}\NormalTok{, }\DataTypeTok{Rational}\NormalTok{\{}\DataTypeTok{Int64}\NormalTok{\}\}[]}
    \FunctionTok{isabstracttype}\NormalTok{(T) }\OperatorTok{||} \ControlFlowTok{return}\NormalTok{ [(T, }\FloatTok{1}\NormalTok{, }\FloatTok{1}\NormalTok{, }\FloatTok{1}\OperatorTok{//}\FloatTok{1}\NormalTok{)]}

\NormalTok{    subT }\OperatorTok{=} \FunctionTok{subtypes}\NormalTok{(T)}
    
\NormalTok{    typelist }\OperatorTok{=} \DataTypeTok{Tuple}\NormalTok{\{}\DataTypeTok{Type}\NormalTok{, }\DataTypeTok{Int64}\NormalTok{, }\DataTypeTok{Int64}\NormalTok{, }\DataTypeTok{Rational}\NormalTok{\{}\DataTypeTok{Int64}\NormalTok{\}\}[]}
\NormalTok{    offset }\OperatorTok{=} \FloatTok{0}
    \ControlFlowTok{for}\NormalTok{ S }\OperatorTok{∈}\NormalTok{ subT}
        
        \CommentTok{\# Prevents an infinite loop}
\NormalTok{        S }\OperatorTok{==} \DataTypeTok{Any} \OperatorTok{\&\&} \ControlFlowTok{continue}
        \CommentTok{\# Recursively gets the arrangement of each subtype}
\NormalTok{        Stypelist }\OperatorTok{=} \FunctionTok{arrange}\NormalTok{(S)}

        \CommentTok{\# Alters the arrangement to fit with the new graph}
        \FunctionTok{append!}\NormalTok{(typelist,}
\NormalTok{            [st }\OperatorTok{.+}\NormalTok{ (}\ConstantTok{nothing}\NormalTok{, }\ConstantTok{nothing}\NormalTok{, }\FloatTok{1}\NormalTok{, offset) for st }\OperatorTok{∈}\NormalTok{ Stypelist]}
\NormalTok{        )}
        \CommentTok{\# Recalculates the offset to accommodate for the new points added}
        \FunctionTok{isempty}\NormalTok{(Stypelist) }\OperatorTok{||}\NormalTok{ (offset }\OperatorTok{+=}\NormalTok{ (Stypelist[}\KeywordTok{end}\NormalTok{])[}\FloatTok{2}\NormalTok{] }\OperatorTok{+} \FloatTok{1}\NormalTok{)}
        
    \ControlFlowTok{end}
    \CommentTok{\# Adds the tuple for T itself to the end of the vector, and returns}
    \FunctionTok{push!}\NormalTok{(typelist, (T, offset, }\FloatTok{1}\NormalTok{, offset}\OperatorTok{//}\FloatTok{2}\NormalTok{))}
    
\KeywordTok{end}

\ImportTok{using} \BuiltInTok{Plots}
\CommentTok{\# Plots the type tree for the subtypes of T}
\KeywordTok{function} \FunctionTok{typetree}\NormalTok{(T}\OperatorTok{::}\DataTypeTok{Type}\NormalTok{)}

\NormalTok{    typelist }\OperatorTok{=} \FunctionTok{arrange}\NormalTok{(T)}

\NormalTok{    types}\OperatorTok{::}\DataTypeTok{Vector\{Type\}                 }\OperatorTok{=}\NormalTok{ [st[}\FloatTok{1}\NormalTok{] for st }\OperatorTok{∈}\NormalTok{ typelist]}
\NormalTok{    spans}\OperatorTok{::}\DataTypeTok{Vector\{Int64\}                }\OperatorTok{=}\NormalTok{ [st[}\FloatTok{2}\NormalTok{] for st }\OperatorTok{∈}\NormalTok{ typelist]}
\NormalTok{    depths}\OperatorTok{::}\DataTypeTok{Vector\{Int64\}               }\OperatorTok{=}\NormalTok{ [st[}\FloatTok{3}\NormalTok{] for st }\OperatorTok{∈}\NormalTok{ typelist]}
\NormalTok{    vpositions}\OperatorTok{::}\DataTypeTok{Vector\{Rational\{Int64\}\} }\OperatorTok{=}\NormalTok{ [st[}\FloatTok{4}\NormalTok{] for st }\OperatorTok{∈}\NormalTok{ typelist]}
\NormalTok{    n }\OperatorTok{=} \FunctionTok{length}\NormalTok{(typelist)}

\NormalTok{    xgap }\OperatorTok{=} \FloatTok{750} \OperatorTok{÷} \FunctionTok{max}\NormalTok{(depths}\OperatorTok{...}\NormalTok{)}
\NormalTok{    ygap }\OperatorTok{=} \FloatTok{750} \OperatorTok{÷}\NormalTok{ spans[}\KeywordTok{end}\NormalTok{]}

    \FunctionTok{plot}\NormalTok{(}
\NormalTok{        size }\OperatorTok{=}\NormalTok{ (}\FloatTok{750}\NormalTok{, }\FloatTok{750}\NormalTok{),}
\NormalTok{        grid }\OperatorTok{=} \ConstantTok{false}\NormalTok{,}
\NormalTok{        showaxis }\OperatorTok{=} \ConstantTok{false}\NormalTok{,}
\NormalTok{        legend }\OperatorTok{=} \ConstantTok{false}\NormalTok{,}
\NormalTok{        xlims }\OperatorTok{=}\NormalTok{ (xgap }\OperatorTok{{-}} \FloatTok{50}\NormalTok{, }\FloatTok{750} \OperatorTok{+} \FloatTok{50}\NormalTok{),}
\NormalTok{        ylims }\OperatorTok{=}\NormalTok{ (ygap }\OperatorTok{{-}} \FloatTok{20}\NormalTok{, }\FloatTok{750} \OperatorTok{+} \FloatTok{20}\NormalTok{)}
\NormalTok{    )}

    \CommentTok{\# Abstract types in grey, concrete types in black}
    \FunctionTok{plot!}\NormalTok{(}
\NormalTok{        annotations }\OperatorTok{=}\NormalTok{ [}
\NormalTok{            (depths[i] }\OperatorTok{*}\NormalTok{ xgap, vpositions[i] }\OperatorTok{*}\NormalTok{ ygap,}
\NormalTok{            (types[i], }\FloatTok{10}\NormalTok{, }\FunctionTok{isabstracttype}\NormalTok{(types[i]) ? }\OperatorTok{:}\NormalTok{grey }\OperatorTok{:} \OperatorTok{:}\NormalTok{black), }\StringTok{"sans{-}serif"}\NormalTok{)}
\NormalTok{            for i }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\NormalTok{n}
\NormalTok{        ]}
\NormalTok{    )}

\NormalTok{    lines }\OperatorTok{=}\NormalTok{ [}
\NormalTok{        ([(depths[i] }\OperatorTok{+} \FloatTok{1}\OperatorTok{//}\FloatTok{2}\NormalTok{) }\OperatorTok{*}\NormalTok{ xgap, (depths[i] }\OperatorTok{+} \FloatTok{1}\OperatorTok{//}\FloatTok{2}\NormalTok{) }\OperatorTok{*}\NormalTok{ xgap],}
\NormalTok{        [(vpositions[i] }\OperatorTok{{-}}\NormalTok{ spans[i]}\OperatorTok{//}\FloatTok{2}\NormalTok{) }\OperatorTok{*}\NormalTok{ ygap, (vpositions[i] }\OperatorTok{+}\NormalTok{ spans[i]}\OperatorTok{//}\FloatTok{2}\NormalTok{) }\OperatorTok{*}\NormalTok{ ygap])}
\NormalTok{        for i }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\NormalTok{n if }\FunctionTok{isabstracttype}\NormalTok{(types[i])}
\NormalTok{    ]}

    \CommentTok{\# Lines delineate the set of subtypes for each abstract type}
    \FunctionTok{plot!}\NormalTok{(}
\NormalTok{        [}\FunctionTok{Shape}\NormalTok{(line}\OperatorTok{...}\NormalTok{) for line }\OperatorTok{∈}\NormalTok{ lines],}
\NormalTok{        fillcolor }\OperatorTok{=} \OperatorTok{:}\NormalTok{white,}
\NormalTok{        linecolor }\OperatorTok{=} \OperatorTok{:}\NormalTok{lightgrey,}
\NormalTok{        linewidth }\OperatorTok{=} \FloatTok{4}
\NormalTok{    )}
    
\KeywordTok{end}

\FunctionTok{typetree}\NormalTok{(}\DataTypeTok{Number}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/basics/numeric-types/numeric-types_files/figure-pdf/cell-6-output-1.pdf}

}

\end{figure}

Suppose we want to write a function that will work for all types of
integers. Integers could come in many forms, such as \texttt{UInt8} or
\texttt{Int64}, but instead of writing a separate method for each of
these, we can just write one for the abstract type \texttt{Integer}
instead, and it will be called regardless of the exact type of the data
we input (as long as it is below \texttt{Integer} on this diagram).

We'll explore each of these types in more detail in turn, seeing how in
some cases they differ from the way we'd expect numbers to behave, and
how we can make use of this or avoid the problems it causes.

\hypertarget{the-int-and-uint-types}{%
\section{\texorpdfstring{The \texttt{Int} and \texttt{UInt}
types}{The Int and UInt types}}\label{the-int-and-uint-types}}

The most common numeric types are in the \texttt{Int} family,
specifically \texttt{Int64}, although the others work similarly, so
we'll cover them all together. We'll also look at the \texttt{UInt}
family, which is much the same as well, but with a minor difference that
makes it applicable in different scenarios.

First, why are they called \texttt{Int} and \texttt{UInt}? \texttt{Int}
is short for integer, and indeed this describes the numbers that can be
stored in these formats: whole numbers. Meanwhile, the \texttt{U} in
\texttt{UInt} stands for \texttt{Unsigned} (as we see in the diagram
above), which means we can't have a minus sign, so we can only have
positive numbers or zero, which may or may not be desirable. If we do
need negative numbers, then we need to use a \texttt{Signed} type, such
as one of the \texttt{Int} types, instead. We're not considering
\texttt{BigInt} here, as it works differently, so we'll cover than in a
later section.

\hypertarget{uint}{%
\subsection{\texorpdfstring{\texttt{UInt}}{UInt}}\label{uint}}

Before we look at any of these data types, let's consider a more
familiar example. Suppose we have a calculator with an 8 digit display:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Defines which segments light up for each number}
\CommentTok{\# nothing represents an empty space, {-}1 represents a minus sign}
\NormalTok{digitionary }\OperatorTok{=} \FunctionTok{Dict}\NormalTok{(}
    \ConstantTok{nothing} \OperatorTok{=\textgreater{}} \FunctionTok{ntuple}\NormalTok{(\_ }\OperatorTok{{-}\textgreater{}} \ConstantTok{false}\NormalTok{, }\FloatTok{7}\NormalTok{),}
    \OperatorTok{{-}}\FloatTok{1} \OperatorTok{=\textgreater{}}\NormalTok{ (}\ConstantTok{false}\NormalTok{, }\ConstantTok{false}\NormalTok{, }\ConstantTok{false}\NormalTok{, }\ConstantTok{true}\NormalTok{ , }\ConstantTok{false}\NormalTok{, }\ConstantTok{false}\NormalTok{, }\ConstantTok{false}\NormalTok{),}
    \FloatTok{0}  \OperatorTok{=\textgreater{}}\NormalTok{ (}\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{false}\NormalTok{, }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ ),}
    \FloatTok{1}  \OperatorTok{=\textgreater{}}\NormalTok{ (}\ConstantTok{false}\NormalTok{, }\ConstantTok{false}\NormalTok{, }\ConstantTok{true}\NormalTok{ , }\ConstantTok{false}\NormalTok{, }\ConstantTok{false}\NormalTok{, }\ConstantTok{true}\NormalTok{ , }\ConstantTok{false}\NormalTok{),}
    \FloatTok{2}  \OperatorTok{=\textgreater{}}\NormalTok{ (}\ConstantTok{true}\NormalTok{ , }\ConstantTok{false}\NormalTok{, }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{false}\NormalTok{, }\ConstantTok{true}\NormalTok{ ),}
    \FloatTok{3}  \OperatorTok{=\textgreater{}}\NormalTok{ (}\ConstantTok{true}\NormalTok{ , }\ConstantTok{false}\NormalTok{, }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{false}\NormalTok{, }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ ),}
    \FloatTok{4}  \OperatorTok{=\textgreater{}}\NormalTok{ (}\ConstantTok{false}\NormalTok{, }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{false}\NormalTok{, }\ConstantTok{true}\NormalTok{ , }\ConstantTok{false}\NormalTok{),}
    \FloatTok{5}  \OperatorTok{=\textgreater{}}\NormalTok{ (}\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{false}\NormalTok{, }\ConstantTok{true}\NormalTok{ , }\ConstantTok{false}\NormalTok{, }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ ),}
    \FloatTok{6}  \OperatorTok{=\textgreater{}}\NormalTok{ (}\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{false}\NormalTok{, }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ ),}
    \FloatTok{7}  \OperatorTok{=\textgreater{}}\NormalTok{ (}\ConstantTok{true}\NormalTok{ , }\ConstantTok{false}\NormalTok{, }\ConstantTok{true}\NormalTok{ , }\ConstantTok{false}\NormalTok{, }\ConstantTok{false}\NormalTok{, }\ConstantTok{true}\NormalTok{ , }\ConstantTok{false}\NormalTok{),}
    \FloatTok{8}  \OperatorTok{=\textgreater{}}\NormalTok{ (}\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ ),}
    \FloatTok{9}  \OperatorTok{=\textgreater{}}\NormalTok{ (}\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ , }\ConstantTok{false}\NormalTok{, }\ConstantTok{true}\NormalTok{ , }\ConstantTok{true}\NormalTok{ ),}
\NormalTok{)}

\CommentTok{\# Defines the corners of the seven segments}
\NormalTok{shapedex }\OperatorTok{=} \FunctionTok{Dict}\NormalTok{(}
    \FloatTok{1} \OperatorTok{=\textgreater{}}\NormalTok{ ([}\OperatorTok{{-}}\FloatTok{25}\NormalTok{, }\OperatorTok{{-}}\FloatTok{20}\NormalTok{, }\FloatTok{20}\NormalTok{, }\FloatTok{25}\NormalTok{, }\FloatTok{20}\NormalTok{, }\OperatorTok{{-}}\FloatTok{20}\NormalTok{], [}\FloatTok{60}\NormalTok{, }\FloatTok{65}\NormalTok{, }\FloatTok{65}\NormalTok{, }\FloatTok{60}\NormalTok{, }\FloatTok{55}\NormalTok{, }\FloatTok{55}\NormalTok{]),}
    \FloatTok{2} \OperatorTok{=\textgreater{}}\NormalTok{ ([}\OperatorTok{{-}}\FloatTok{30}\NormalTok{, }\OperatorTok{{-}}\FloatTok{35}\NormalTok{, }\OperatorTok{{-}}\FloatTok{35}\NormalTok{, }\OperatorTok{{-}}\FloatTok{30}\NormalTok{, }\OperatorTok{{-}}\FloatTok{25}\NormalTok{, }\OperatorTok{{-}}\FloatTok{25}\NormalTok{], [}\FloatTok{5}\NormalTok{, }\FloatTok{10}\NormalTok{, }\FloatTok{50}\NormalTok{, }\FloatTok{55}\NormalTok{, }\FloatTok{50}\NormalTok{, }\FloatTok{10}\NormalTok{]),}
    \FloatTok{3} \OperatorTok{=\textgreater{}}\NormalTok{ ([}\FloatTok{30}\NormalTok{, }\FloatTok{35}\NormalTok{, }\FloatTok{35}\NormalTok{, }\FloatTok{30}\NormalTok{, }\FloatTok{25}\NormalTok{, }\FloatTok{25}\NormalTok{], [}\FloatTok{5}\NormalTok{, }\FloatTok{10}\NormalTok{, }\FloatTok{50}\NormalTok{, }\FloatTok{55}\NormalTok{, }\FloatTok{50}\NormalTok{, }\FloatTok{10}\NormalTok{]),}
    \FloatTok{4} \OperatorTok{=\textgreater{}}\NormalTok{ ([}\OperatorTok{{-}}\FloatTok{25}\NormalTok{, }\OperatorTok{{-}}\FloatTok{20}\NormalTok{, }\FloatTok{20}\NormalTok{, }\FloatTok{25}\NormalTok{, }\FloatTok{20}\NormalTok{, }\OperatorTok{{-}}\FloatTok{20}\NormalTok{], [}\FloatTok{0}\NormalTok{, }\FloatTok{5}\NormalTok{, }\FloatTok{5}\NormalTok{, }\FloatTok{0}\NormalTok{, }\OperatorTok{{-}}\FloatTok{5}\NormalTok{, }\OperatorTok{{-}}\FloatTok{5}\NormalTok{]),}
    \FloatTok{5} \OperatorTok{=\textgreater{}}\NormalTok{ ([}\OperatorTok{{-}}\FloatTok{30}\NormalTok{, }\OperatorTok{{-}}\FloatTok{35}\NormalTok{, }\OperatorTok{{-}}\FloatTok{35}\NormalTok{, }\OperatorTok{{-}}\FloatTok{30}\NormalTok{, }\OperatorTok{{-}}\FloatTok{25}\NormalTok{, }\OperatorTok{{-}}\FloatTok{25}\NormalTok{], [}\OperatorTok{{-}}\FloatTok{5}\NormalTok{, }\OperatorTok{{-}}\FloatTok{10}\NormalTok{, }\OperatorTok{{-}}\FloatTok{50}\NormalTok{, }\OperatorTok{{-}}\FloatTok{55}\NormalTok{, }\OperatorTok{{-}}\FloatTok{50}\NormalTok{, }\OperatorTok{{-}}\FloatTok{10}\NormalTok{]),}
    \FloatTok{6} \OperatorTok{=\textgreater{}}\NormalTok{ ([}\FloatTok{30}\NormalTok{, }\FloatTok{35}\NormalTok{, }\FloatTok{35}\NormalTok{, }\FloatTok{30}\NormalTok{, }\FloatTok{25}\NormalTok{, }\FloatTok{25}\NormalTok{], [}\OperatorTok{{-}}\FloatTok{5}\NormalTok{, }\OperatorTok{{-}}\FloatTok{10}\NormalTok{, }\OperatorTok{{-}}\FloatTok{50}\NormalTok{, }\OperatorTok{{-}}\FloatTok{55}\NormalTok{, }\OperatorTok{{-}}\FloatTok{50}\NormalTok{, }\OperatorTok{{-}}\FloatTok{10}\NormalTok{]),}
    \FloatTok{7} \OperatorTok{=\textgreater{}}\NormalTok{ ([}\OperatorTok{{-}}\FloatTok{25}\NormalTok{, }\OperatorTok{{-}}\FloatTok{20}\NormalTok{, }\FloatTok{20}\NormalTok{, }\FloatTok{25}\NormalTok{, }\FloatTok{20}\NormalTok{, }\OperatorTok{{-}}\FloatTok{20}\NormalTok{], [}\OperatorTok{{-}}\FloatTok{60}\NormalTok{, }\OperatorTok{{-}}\FloatTok{55}\NormalTok{, }\OperatorTok{{-}}\FloatTok{55}\NormalTok{, }\OperatorTok{{-}}\FloatTok{60}\NormalTok{, }\OperatorTok{{-}}\FloatTok{65}\NormalTok{, }\OperatorTok{{-}}\FloatTok{65}\NormalTok{])}
\NormalTok{)}

\CommentTok{\# N is the number to be displayed}
\CommentTok{\# n is the number of digits to display it in}
\CommentTok{\# If negative numbers are allowed, the first digit will be taken up by a minus sign}
\KeywordTok{function} \FunctionTok{sevensegment}\NormalTok{(N, n, allownegative }\OperatorTok{=} \ConstantTok{false}\NormalTok{)}

    \CommentTok{\# The number that will actually be displayed}
    \CommentTok{\# Without negatives allowed, functions like UInt}
    \CommentTok{\# With negatives allowed, not exactly like Int, as can\textquotesingle{}t display {-}10\^{}(n{-}1)}
\NormalTok{    N }\OperatorTok{=}\NormalTok{ allownegative ?}
        \FunctionTok{mod}\NormalTok{(N, }\FunctionTok{{-}}\NormalTok{(}\FloatTok{10}\OperatorTok{\^{}}\NormalTok{(n}\OperatorTok{{-}}\FloatTok{1}\NormalTok{)}\OperatorTok{{-}}\FloatTok{1}\NormalTok{)}\OperatorTok{:}\NormalTok{(}\FloatTok{10}\OperatorTok{\^{}}\NormalTok{(n}\OperatorTok{{-}}\FloatTok{1}\NormalTok{)}\OperatorTok{{-}}\FloatTok{1}\NormalTok{)) }\OperatorTok{:}
        \FunctionTok{mod}\NormalTok{(N, }\FloatTok{10}\OperatorTok{\^{}}\NormalTok{n)}

    \CommentTok{\# Logic to work out the sequence of digits to be displayed}
\NormalTok{    digitsN }\OperatorTok{=} \FunctionTok{digits}\NormalTok{(}\FunctionTok{abs}\NormalTok{(N))}
\NormalTok{    truncateddigitsN }\OperatorTok{=} \FunctionTok{reverse}\NormalTok{(digitsN[}\FloatTok{1}\OperatorTok{:}\FunctionTok{min}\NormalTok{(}\FunctionTok{length}\NormalTok{(digitsN), n }\OperatorTok{{-}}\NormalTok{ allownegative)])}
\NormalTok{    displaydigits }\OperatorTok{=}\NormalTok{ [}
\NormalTok{        allownegative ? (N }\OperatorTok{\textless{}} \FloatTok{0}\NormalTok{ ? }\OperatorTok{{-}}\FloatTok{1} \OperatorTok{:} \ConstantTok{nothing}\NormalTok{) }\OperatorTok{:} \DataTypeTok{Nothing}\NormalTok{[];}
        \FunctionTok{fill}\NormalTok{(}\ConstantTok{nothing}\NormalTok{, n }\OperatorTok{{-}}\NormalTok{ allownegative }\OperatorTok{{-}} \FunctionTok{length}\NormalTok{(truncateddigitsN));}
\NormalTok{        truncateddigitsN}
\NormalTok{    ]}

    \CommentTok{\# Creates canvas to work on}
\NormalTok{    p }\OperatorTok{=} \FunctionTok{plot}\NormalTok{(}
\NormalTok{        size }\OperatorTok{=}\NormalTok{ (}\FloatTok{75}\NormalTok{n }\OperatorTok{+} \FloatTok{20}\NormalTok{, }\FloatTok{150}\NormalTok{),}
\NormalTok{        grid }\OperatorTok{=} \ConstantTok{false}\NormalTok{,}
\NormalTok{        showaxis }\OperatorTok{=} \ConstantTok{false}\NormalTok{,}
\NormalTok{        legend }\OperatorTok{=} \ConstantTok{false}\NormalTok{,}
\NormalTok{        ticks }\OperatorTok{=} \ConstantTok{false}\NormalTok{,}
\NormalTok{        framestyle }\OperatorTok{=} \OperatorTok{:}\NormalTok{origin,}
\NormalTok{        xlims }\OperatorTok{=}\NormalTok{ (}\FloatTok{25}\NormalTok{, }\FloatTok{75}\NormalTok{n }\OperatorTok{+} \FloatTok{35}\NormalTok{),}
\NormalTok{        ylims }\OperatorTok{=}\NormalTok{ (}\OperatorTok{{-}}\FloatTok{75}\NormalTok{, }\FloatTok{75}\NormalTok{),}
\NormalTok{        bg }\OperatorTok{=} \OperatorTok{:}\NormalTok{black}
\NormalTok{    )}

    \CommentTok{\# Plots segments with colours according to digits}
    \ControlFlowTok{for}\NormalTok{ i }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\NormalTok{n}
        \ControlFlowTok{for}\NormalTok{ j }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\FloatTok{7}
            \FunctionTok{plot!}\NormalTok{(}
\NormalTok{                p,}
                \FunctionTok{Shape}\NormalTok{(}\FunctionTok{broadcast}\NormalTok{(}\OperatorTok{.+}\NormalTok{, shapedex[j], (}\FloatTok{75}\NormalTok{i, }\FloatTok{0}\NormalTok{))}\OperatorTok{...}\NormalTok{),}
\NormalTok{                fillcolor }\OperatorTok{=}\NormalTok{ (digitionary[displaydigits[i]][j] ? }\OperatorTok{:}\NormalTok{red }\OperatorTok{:} \OperatorTok{:}\NormalTok{grey15),}
\NormalTok{                linewidth }\OperatorTok{=} \FloatTok{0}
\NormalTok{            )}
        \ControlFlowTok{end}
    \ControlFlowTok{end}

    \ControlFlowTok{return}\NormalTok{ p}
    
\KeywordTok{end}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Custom function}
\CommentTok{\# First argument is number to be displayed}
\CommentTok{\# Second argument is number of digits}
\FunctionTok{sevensegment}\NormalTok{(}\FloatTok{0}\NormalTok{, }\FloatTok{8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/basics/numeric-types/numeric-types_files/figure-pdf/cell-8-output-1.pdf}

}

\end{figure}

This calculator can display the numbers from \texttt{0} to
\texttt{99999999} (it doesn't have a minus sign). What if we try to
calculate something that goes beyond this range? For example, let's try
multiplying \texttt{12345} by \texttt{67890}, to which the correct
answer would be the nine digit number \texttt{838102050}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sevensegment}\NormalTok{(}\FloatTok{12345} \OperatorTok{*} \FloatTok{67890}\NormalTok{, }\FloatTok{8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/basics/numeric-types/numeric-types_files/figure-pdf/cell-9-output-1.pdf}

}

\end{figure}

It didn't have space for the first digit \texttt{8}, so it simply cut it
off and showed the smaller digits. By analogy to water overflowing a
container with lesser volume, this is called \emph{integer overflow},
with the excess digits being simply lost. Of course, most calculators
are designed to deal with this sort of issue in a more elegant fashion,
but as we'll see, this is exactly what will happen in Julia when we try
calculations with answers that are too big.

A related error is \emph{integer underflow}, which happens when we try
to calculate a number that is too small to be displayed:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sevensegment}\NormalTok{(}\FloatTok{3} \OperatorTok{{-}} \FloatTok{5}\NormalTok{, }\FloatTok{8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/basics/numeric-types/numeric-types_files/figure-pdf/cell-10-output-1.pdf}

}

\end{figure}

Here, we've tried to subtract \texttt{5} from \texttt{3}, but as we've
already discussed, this calculator can't do negative numbers, so instead
we end up wrapping back around to the biggest numbers that the
calculator can display and counting down from there.

This demonstration shows more or less how the \texttt{UInt} types work.
Each has a set number of bits, or binary digits (since computers work in
binary), to store numeric values in, \texttt{8} for \texttt{UInt8},
\texttt{16} for \texttt{UInt16}, etc. If we consider \texttt{UInt8},
then this has \texttt{8} bits to store numbers, so can only accurately
describe the numbers \texttt{0} to \texttt{255}, since
\texttt{255\ =\ 2\^{}8\ -\ 1}. If we try to add one more, then:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{UInt8}\NormalTok{(}\FloatTok{255}\NormalTok{) }\OperatorTok{+} \FunctionTok{UInt8}\NormalTok{(}\FloatTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0x00
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{UInt8}\NormalTok{(}\FloatTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0x00
\end{verbatim}

The way that these numbers is displayed may look slightly strange, but
this is to distinguish these numbers from \texttt{Int} types, which are
more commonly used. Specifically it is \texttt{0x} (denoting unsigned
integers) followed by the hexadecimal representation (that is, base 16),
but we needn't worry too much about that. What's important is that when
we add \texttt{1} to \texttt{255} as \texttt{UInt8}s, we get \texttt{0},
the expected result of integer overflow. We can also demonstrate integer
underflow:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{UInt8}\NormalTok{(}\FloatTok{0}\NormalTok{) }\OperatorTok{{-}} \FunctionTok{UInt8}\NormalTok{(}\FloatTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0xff
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{UInt8}\NormalTok{(}\FloatTok{255}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0xff
\end{verbatim}

To see a little more clearly how the \texttt{UInt8} type works, we're
lucky enough to be able to see the exact bits that are stored. This is
because \texttt{UInt8}, along with many of the other numeric types we'll
see here are \emph{primitive} types, meaning that they are stored
exactly as the bits that represent them in the computer (the alternative
is a \emph{composite} type, which can be thought of as a list of
property names, with locations where the corresponding data is stored).
Any data which has a primitive type can be input into the inbuilt Julia
function \texttt{bitstring}, which outputs a string of \texttt{0}s and
\texttt{1}s that are exactly the bits used to represent that number. For
example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{bitstring}\NormalTok{(}\FunctionTok{UInt8}\NormalTok{(}\FloatTok{100}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"01100100"
\end{verbatim}

Indeed, 100 = 64 + 32 + 4, so it is represented in binary as
\texttt{1100100}, with the extra \texttt{0} in the bit string above to
pad it out to 8 binary digits as \texttt{UInt8} requires. We can now see
why the integer overflow happens, if we try to add two numbers and we
end up carrying a \texttt{1} beyond the end of the number, then it is
lost, which has the effect of wrapping back around to where we started.

The other \texttt{UInt} types work much the same, except they take up a
greater number of bits, meaning that they can store bigger numbers at
the cost of more space. For example, the largest number that can be
stored as a \texttt{UInt128} is
\texttt{340282366920938463463374607431768211455},
i.e.~\texttt{2\^{}128\ -\ 1}.

Depending on what our data is actually representing, \texttt{UInt} types
may or may not be appropriate. For example, if we're storing the
population of various cities, this will never be negative, and the
maximum \texttt{UInt32} is \texttt{4294967295} (approximately four
billion), so \texttt{UInt32} may be appropriate as a choice of type.
However, if we're storing the change in population from the last year,
then this could be negative, so a \texttt{UInt} type would no longer
suffice. Instead, we need a signed \texttt{Int} type.

\hypertarget{int}{%
\subsection{\texorpdfstring{\texttt{Int}}{Int}}\label{int}}

To see how \texttt{Int} types work, we'll return again to the
calculator, but this time add a third argument. The \texttt{true} here
sets a variable to allow negative numbers to be shown:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sevensegment}\NormalTok{(}\OperatorTok{{-}}\FloatTok{1234}\NormalTok{, }\FloatTok{8}\NormalTok{, }\ConstantTok{true}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/basics/numeric-types/numeric-types_files/figure-pdf/cell-16-output-1.pdf}

}

\end{figure}

Great, so this is an improvement to the calculator, right? It could be,
but it has come with a cost, we've lost use of the first digit! So we
can do negative numbers, but we need to compromise by lowering the
maximum value that we can display accurately. What happens if we
overflow this time?

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sevensegment}\NormalTok{(}\FloatTok{9999999} \OperatorTok{+} \FloatTok{1}\NormalTok{, }\FloatTok{8}\NormalTok{, }\ConstantTok{true}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/basics/numeric-types/numeric-types_files/figure-pdf/cell-17-output-1.pdf}

}

\end{figure}

Again, we wrap around, but this time, the smallest number isn't
\texttt{0}, it's \texttt{-9999999}, so that's our answer. Underflows
will occur similarly, wrapping around to the largest number
\texttt{9999999} and counting down as appropriate. This is roughly how
the \texttt{Int} types work, again as a demonstration we'll consider the
smallest one, which is \texttt{Int8}.

We've seen how a \texttt{UInt8} is simply a binary number with a limited
number of digits. For example, if a \texttt{UInt8} has bit string
\texttt{"11010011"}, then we can work out which number this represents
by:

\[
\begin{matrix}
128 & 64 & 32 & 16 & 8 & 4 & 2 & 1 \\\hline
1 & 1 & 0 & 1 & 0 & 0 & 1 & 1
\end{matrix} \qquad \qquad 128 + 64 + 16 + 2 + 1 = 211
\]

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{bitstring}\NormalTok{(}\FunctionTok{UInt8}\NormalTok{(}\FloatTok{211}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"11010011"
\end{verbatim}

The way that \texttt{Int} types such as \texttt{Int8} work is to make
the first digit subtract instead of add if there is a \texttt{1}. We can
think of it as a ``-128s'' place instead of a ``128s'' place, as
follows:

\[
\begin{matrix}
-128 & 64 & 32 & 16 & 8 & 4 & 2 & 1 \\\hline
1 & 1 & 0 & 1 & 0 & 0 & 1 & 1
\end{matrix} \qquad \qquad -128 + 64 + 16 + 2 + 1 = -45
\]

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{bitstring}\NormalTok{(}\FunctionTok{Int8}\NormalTok{(}\OperatorTok{{-}}\FloatTok{45}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"11010011"
\end{verbatim}

This means that \texttt{Int8} can represent any number from
\texttt{-128} to \texttt{127} (as with all the \texttt{Int} types,
there's one more negative number that it can represent than positive).
We can see this as well with bit strings:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{bitstring}\NormalTok{(}\FunctionTok{Int8}\NormalTok{(}\FloatTok{127}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"01111111"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{bitstring}\NormalTok{(}\FunctionTok{Int8}\NormalTok{(}\OperatorTok{{-}}\FloatTok{128}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"10000000"
\end{verbatim}

Similarly, the other \texttt{Int} types work much like their
\texttt{UInt} counterparts, but with the first bit corresponding to a
subtracting of a power of 2 rather than the addition of one.

In general, \texttt{Int64} is the default whenever you type a number
into Julia. An \texttt{Int} type is default rather than a \texttt{UInt}
as it's generally more useful to have the ability to use negative
numbers if needed, rather than a load more large positive numbers. As
for \texttt{64}, modern systems run on 64-bit architecture, i.e.~they
are built to deal with data in blocks of 64 bits, so it's sensible to
store numbers in that format. Some older systems may use 32-bit
architecture, in which case Julia will use \texttt{Int32} as the default
type correspondingly.

However, if you type in a number that's too big (or too small, if it's
negative) to be stored in \texttt{Int64} format, Julia won't truncate
it, instead, it will change the type of the input. First, it will try to
store it as an \texttt{Int128}, and if that doesn't work, it will store
it as a \texttt{BigInt}. We can demonstrate this with the
\texttt{typemax} function, which will tell us that maximum value that
the input type can store:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typemax}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
9223372036854775807
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\FloatTok{9223372036854775807}\NormalTok{) }\CommentTok{\# Biggest possible Int64}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Int64
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\FloatTok{9223372036854775808}\NormalTok{) }\CommentTok{\# Too big to be an Int64, so is an Int128}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Int128
\end{verbatim}

\hypertarget{bigint-and-bool}{%
\section{\texorpdfstring{\texttt{BigInt} and
\texttt{Bool}}{BigInt and Bool}}\label{bigint-and-bool}}

We've got two more types under the umbrella of \texttt{Integer} that we
haven't met yet, the \texttt{Signed} type \texttt{BigInt}, and the type
\texttt{Bool} which is neither \texttt{Signed} nor \texttt{Unsigned}.
Let's investigate them further.

\hypertarget{bigint}{%
\subsection{\texorpdfstring{\texttt{BigInt}}{BigInt}}\label{bigint}}

As its name suggests, \texttt{BigInt} is used for storing big integers,
specifically those that are too big to be stored in any of the normal
formats. Since it is \texttt{Signed}, we can infer (correctly) that it
is also able to store integers that are too small, smaller than the
smallest negative number that \texttt{Int128} can handle. Indeed, any
integer that you can type in can be stored precisely as a
\texttt{BigInt}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{googol }\OperatorTok{=} \FloatTok{10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(googol)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
BigInt
\end{verbatim}

The drawback to \texttt{BigInt} is that Julia doesn't get much
information about the number from the type alone (with \texttt{Int64}
for example, Julia knows that the number will be a certain size), so
calculations cannot be optimised as well. As a result, \texttt{BigInt}
is recommended to be used only when the precision or size requires it.

\hypertarget{bool}{%
\subsection{\texorpdfstring{\texttt{Bool}}{Bool}}\label{bool}}

The final \texttt{Integer} type is \texttt{Bool}, which isn't like the
other \texttt{Signed} and \texttt{Unsigned} types. In fact, we often
don't think of it as a number at all, rather we think of it in terms of
its two possible values, \texttt{true} and \texttt{false}, which are
called the logical values, or Boolean values (hence \texttt{Bool}).
\texttt{Bool} values are returned by various functions like
\texttt{iseven}, and are used most notably as conditions in \texttt{if}
statements, or alternative Julia syntax such as short-circuited
operations \texttt{\&\&} and \texttt{\textbar{}\textbar{}}, as well as
the ternary operator \texttt{?\ :}.

Why are \texttt{Bool}s considered to be integers then? \texttt{Bool} is
a primitive type, so we can use \texttt{bitstring} to help find out:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{bitstring}\NormalTok{(}\ConstantTok{false}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"00000000"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{bitstring}\NormalTok{(}\ConstantTok{true}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"00000001"
\end{verbatim}

The answer is that they really are integers, \texttt{false} is
\texttt{0} and \texttt{true}is \texttt{1}! Indeed, some programming
languages don't distinguish a special data type for \texttt{true} and
\texttt{false}, instead just using \texttt{1} and \texttt{0}
respectively, which means that some programmers are used to doing things
such as multiplying Boolean values together for the logical operation
\texttt{AND} (where \texttt{x\ AND\ y} is \texttt{true} if both
\texttt{x} and \texttt{y} are \texttt{true}, otherwise it is
\texttt{false}, just as \texttt{x\ *\ y} is \texttt{1} if both
\texttt{x} and \texttt{y} are \texttt{1}, otherwise it is \texttt{0}).
To allow for this, Julia treats \texttt{Bool} as a type of
\texttt{Number}, and defines operations such as:

\begin{Shaded}
\begin{Highlighting}[]
\ConstantTok{true} \OperatorTok{+} \FloatTok{7} \CommentTok{\# 1 + 7 = 8}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ConstantTok{true} \OperatorTok{*} \ConstantTok{false} \CommentTok{\# 1 * 0 = 0}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
false
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ConstantTok{false} \OperatorTok{\^{}} \ConstantTok{false} \CommentTok{\# 0 \^{} 0 = 1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Convention}, colframe=quarto-callout-tip-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Operations like this, although possible, should be avoided, as they are
needlessly confusing. More typical operations between \texttt{Bool}
types are logical operations, like \texttt{!}, \texttt{\&\&},
\texttt{\textbar{}\textbar{}} which we'll meet in
Chapter~\ref{sec-controlflow} when we talk about conditionals.

\end{tcolorbox}

\hypertarget{the-float-types}{%
\section{\texorpdfstring{The \texttt{Float}
types}{The Float types}}\label{the-float-types}}

We've seen many ways of representing integers, but from the type diagram
we can see that there are many other types of numbers that Julia can
represent. Of these, the types that come under the abstract umbrella
\texttt{AbstractFloat} are the most important, particularly
\texttt{Float16}, \texttt{Float32}, and \texttt{Float64}. These are not
unique to Julia, indeed the industry standard \emph{IEEE-754} ensures
that across all programming languages and all systems, such numbers
behave exactly the same, which as we'll see is necessary due to their
many quirks.

\hypertarget{floating-point-numbers}{%
\subsection{Floating-point numbers}\label{floating-point-numbers}}

In this context, \texttt{Float} means \emph{floating-point number},
which is a number defined by three parts:

\begin{itemize}
\item
  The \emph{sign} (either positive or negative)
\item
  The significant digits (\emph{mantissa} or \emph{significand})
\item
  The position of the (binary) decimal point relative to those digits
  (\emph{exponent})
\end{itemize}

The inclusion of this final part is what gives the \emph{floating-point}
name, since the decimal point can move around to describe a wider
variety of numbers.

This idea may be familiar as scientific notation. For example, the speed
of light in a vacuum is \(299792458\,\mathrm{ms}^{-1}\) (exactly, as
that defines the length of a metre), but this is often represented as
\(3.00 \times 10^8 \,\mathrm{ms}^{-1}\). This is positive, so we don't
write the sign, but we understand that the lack of a sign means
positive. We choose a level of precision of three significant figures,
with the first three significant figures being \(3\), \(0\), \(0\) in
this instance, and we write this as a decimal with the decimal point
placed after the first digit. Finally, we multiply by an appropriate
power of ten to match the size of the exact number we started with, here
being \(10^8\). Assuming that it is understood that we are working with
three significant figures, we could write this even more compactly as
\texttt{+3008}, where the \texttt{+} tells us that the number is
positive, the first three digits after that are the significant figures
or mantissa, and the rest (the \texttt{8}) is the exponent. While this
format is pretty unreadable to human eyes, it turns out to be rather
nice for computers.

Floating-point numbers use the same idea. As their names suggest,
\texttt{Float16}, \texttt{Float32}, and \texttt{Float64} (also sometimes
known as \emph{half}, \emph{single}, and \emph{double} precision for
historical reasons) have 16, 32, and 64 binary digits to use. The first
in each case is always the sign bit (\texttt{0} for positive, \texttt{1}
for negative), with the rest needing to be split between the exponent
and the mantissa. This is an arbitrary but important choice, with the
standard \emph{IEEE-754} decreeing the following split:

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Type & Bits for exponent & Bits for mantissa \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{Float16} & 5 & 10 \\
\texttt{Float32} & 8 & 23 \\
\texttt{Float64} & 11 & 52 \\
\end{longtable}

\hypertarget{bit-representation}{%
\subsection{Bit representation}\label{bit-representation}}

What does this actually look like in bits? Again, these three types are
primitive types, so we can investigate as before with the
\texttt{bitstring} function. Any decimal typed into Julia will be
interpreted as a \texttt{Float64} automatically, but we'll convert to
\texttt{Float16} for a simpler example.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{bitstring}\NormalTok{(}\FunctionTok{Float16}\NormalTok{(}\FloatTok{0.1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"0010111001100110"
\end{verbatim}

Referring to the table above, we see that this splits into three parts
as:

\begin{itemize}
\item
  Sign bit \texttt{0} (so positive)
\item
  Exponent bits \texttt{01011}
\item
  Mantissa bits \texttt{1001100110}
\end{itemize}

The sign bit is straightforward enough, but the exponent and mantissa
bits are not quite as they seem. With a 5 bit exponent, we could expect
to represent any of the numbers from \(0\) to \(31\), but this is
useless for representing any number between \(0\) and \(1\), as they all
have negative exponents. Therefore, there is an inbuilt offset of
\(-15\), so that instead we represent the exponents \(-15\) to \(16\).
In fact, we do something different (see later) when the exponent bits
are all \texttt{0} or all \texttt{1}, so the normal exponents that we
can represent are \(-14\) to \(15\) for \texttt{Float16}s. This works
similarly for \texttt{Float32}s and \texttt{Float64}s, with exponents
\(-126\) to \(127\) and \(-1022\) to \(1023\) allowed respectively.

As for the mantissa, we could simply store the first 10 significant
bits, but that would actually be a little redundant, as in binary, the
first bit would (apart from in one very important case, again see later)
always be a \texttt{1}. As a result, this is \texttt{1} is not stored,
and instead the 2nd to the 11th significant bits are stored. The same is
done for \texttt{Float32} and \texttt{Float64}, with the 2nd to 24th and
2nd to 53rd significant bits stored respectively.

Returning to \(0.1\), let's work backwards. The exponent bits is
\texttt{01011}, which is \(11\) in decimal, but after the offset it
represents \(-4\). The mantissa bits are \texttt{1001100110}, so adding
the implied \texttt{1} back in gives \texttt{1.1001100110}. Then, we
offset by 4 binary places in the negative direction, so the actual
number represented is the binary number \texttt{0.00011001100110}, which
in decimal is \(0.0999755859375\).

What's gone wrong here? We tried to represent \(0.1\), but instead Julia
gave us a number that's just under one forty-thousandth less. The reason
is that, just as we couldn't represent the speed of light exactly with
three significant figures, Julia can't represent \(0.1\) exactly with a
10 bit mantissa. In fact, \(0.1\) is \texttt{0.0001100110011…} in
binary, a recurring decimal, so no matter how many bits we allow for the
mantissa, we could never store it exactly. Julia merely rounds to the
nearest number it can represent, which happens to be
\(0.0999755859375\).

Confusingly, Julia will display exact decimal values such as
\texttt{0.1} even if the actual stored values are different. This is a
design choice of \emph{IEEE-754}, implemented by the \texttt{Base.Ryu}
module (which implements the
\href{https://dl.acm.org/doi/10.1145/3296979.3192369}{Ryū algorithm}),
with the output number being the number with the least digits that
rounds to the given floating-point number. While this prevents strange
behaviour such as typing in \texttt{0.1} and Julia echoing back
\texttt{0.1000000000000000055511151231257827021181583404541015625}
(which is the closest \texttt{Float64} representable value to
\texttt{0.1}, so is actually the true value stored and used for
calculating), it does mask some of the strange behaviour of
floating-point arithmetic that we've started to uncover. Julia also
always displays a decimal point for floating-point numbers, even if they
are integers, to clearly distinguish them from \texttt{Int} types, and
similarly, typing \texttt{.0} will turn an integer input into a
floating-point input.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\FloatTok{12}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Int64
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\FloatTok{12.0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Float64
\end{verbatim}

Instead of actual numbers, floating-point numbers can be more accurately
thought of as an interval of the number line, containing all of the
numbers that round to that specific floating-point representation. For
example, the \texttt{Float16} \texttt{0.1} can be thought of as
\emph{``all the numbers between} \(0.099945068359375\) \emph{and}
\(0.100006103515625\)\emph{``}, since any number in that range would
round to the closest possible representable number, being
\(0.0999755859375\). As the exponent gets smaller, consecutive
floating-point representable numbers get closer together, so the
intervals are much narrower near 0, with the higher density of
representable numbers, and widen towards smaller/larger numbers.

\hypertarget{distribution-of-floating-point-numbers}{%
\subsection{Distribution of floating-point
numbers}\label{distribution-of-floating-point-numbers}}

Since we have only 16 bits to choose, there are a very limited number of
possible \texttt{Float16} numbers. However, unlike with \texttt{Integer}
types, these are not evenly spaced, in fact they are very much
concentrated around 0, as the diagram below demonstrates:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Generate a vector of all possible Float16s from their bitstrings}
\NormalTok{float16s }\OperatorTok{=}\NormalTok{ [}\FunctionTok{reinterpret}\NormalTok{(}\DataTypeTok{Float16}\NormalTok{, n) for n }\OperatorTok{∈} \BaseNTok{0x0000}\OperatorTok{:}\BaseNTok{0xffff}\NormalTok{]}

\CommentTok{\# Parameters for the diagram}
\NormalTok{totalwidth }\OperatorTok{=} \FloatTok{20}
\NormalTok{intervalwidth }\OperatorTok{=} \FloatTok{0.1}

\CommentTok{\# List of endpoints of intervals}
\NormalTok{intervals }\OperatorTok{=} \OperatorTok{{-}}\NormalTok{totalwidth}\OperatorTok{/}\FloatTok{2}\OperatorTok{:}\NormalTok{intervalwidth}\OperatorTok{:}\NormalTok{totalwidth}\OperatorTok{/}\FloatTok{2}
\NormalTok{nbins }\OperatorTok{=} \FunctionTok{length}\NormalTok{(intervals) }\OperatorTok{{-}} \FloatTok{1}
\CommentTok{\# Counts the number of Float16s found in each interval}
\NormalTok{frequencies }\OperatorTok{=}\NormalTok{ [}\FunctionTok{count}\NormalTok{(x }\OperatorTok{{-}\textgreater{}}\NormalTok{ intervals[i] }\OperatorTok{≤}\NormalTok{ x }\OperatorTok{\textless{}}\NormalTok{ intervals[i}\OperatorTok{+}\FloatTok{1}\NormalTok{], float16s) for i }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\NormalTok{nbins]}

\CommentTok{\# Plot the diagram}
\FunctionTok{plot}\NormalTok{(}
\NormalTok{    intervals[}\FloatTok{1}\OperatorTok{:}\NormalTok{nbins] }\OperatorTok{.+}\NormalTok{ intervalwidth}\OperatorTok{/}\FloatTok{2}\NormalTok{,}
\NormalTok{    frequencies }\OperatorTok{./}\NormalTok{ intervalwidth,}
\NormalTok{    legend }\OperatorTok{=} \ConstantTok{false}\NormalTok{,}
\NormalTok{    showaxis }\OperatorTok{=} \OperatorTok{:}\NormalTok{x,}
\NormalTok{    yticks }\OperatorTok{=} \ConstantTok{false}\NormalTok{,}
\NormalTok{    title }\OperatorTok{=} \StringTok{"Density of Float16s"}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/basics/numeric-types/numeric-types_files/figure-pdf/cell-35-output-1.pdf}

}

\end{figure}

This is a consequence of the design, since in general numbers closer to
0 can be represented with fewer significant digits, and so more can be
represented when we are limited to only 10 mantissa bits. However, this
turns out to be an advantage, as it's also useful to distinguish many
small numbers, since the difference between them is relatively much
larger than between bigger numbers (for example, the difference between
\(500\,\mathrm{g}\) and \(501\,\mathrm{g}\) is much less important than
between \(0.5\,\mathrm{g}\) and \(1.5\,\mathrm{g}\).

Given the format we've met above, we can reason what the largest
\texttt{Float16} could be. We want to maximise both the mantissa and the
exponent, but since the exponent can't be all ones, it must be
\texttt{"11110"} (representing a shift of the decimal point by \(15\)),
while the mantissa is \texttt{"1111111111"}. Adding the implied bit, and
moving the decimal point, we get the binary number
\texttt{1111111111100000}, which is \(65504\) in decimal. Indeed:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{bitstring}\NormalTok{(}\FunctionTok{floatmax}\NormalTok{(}\DataTypeTok{Float16}\NormalTok{)) }\CommentTok{\# floatmax gives the largest normally represented floating{-}point number}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"0111101111111111"
\end{verbatim}

Technically, this is the second largest \texttt{Float16} value, since
there is a positive infinite value to represent anything that needs a
larger exponent than \(15\) to describe.

As for the smallest (positive) value that \texttt{Float16} could take,
we might guess that it is when the exponent is \texttt{"00001"} and the
mantissa \texttt{"0000000000"}, which is
\(0.00006103515625 = \tfrac{1}{16384}\).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{bitstring}\NormalTok{(}\FunctionTok{floatmin}\NormalTok{(}\DataTypeTok{Float16}\NormalTok{)) }\CommentTok{\# floatmin gives the smallest positive normally represented floating{-}point number}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"0000010000000000"
\end{verbatim}

However, this is where the exponent \texttt{00000} comes in, working
differently to other exponents. It turns out that there are a lot of
positive floating-point numbers less than this.

\hypertarget{floating-point-arithmetic-and-errors}{%
\subsection{Floating-point arithmetic and
errors}\label{floating-point-arithmetic-and-errors}}

If we think of floating-point numbers as a range in which the true value
lies, then it's unsurprising that arithmetic won't exactly work as we
might expect, particularly when adding numbers of wildly different
sizes, or subtracting numbers that are very close to each other. As an
example, we'll try to calculate the derivative of \(f(x) = x^2\) using
the formula:

\[
\frac{\delta f}{\delta x}(x, \delta x) = \frac{f(x + \delta x) - f(x)}{\delta x}, \qquad f'(x) = \lim_{\delta x \to 0} \left( \frac{\delta f}{\delta x}(x, \delta x) \right)
\]

Since we can't actually plug \(0\) into this formula (we'd end up
dividing \(0\) by \(0\)), we have to try smaller and smaller values of
\(\delta x\). We'll try it with \texttt{Float16} arithmetic to calculate
\(f'(1)\), starting at \texttt{0.1} and making our way down in steps of
\texttt{0.0001} to \texttt{0.0001} (of course, the exact values used in
the computation will be the nearest that \texttt{Float16} can
approximate these by). We'll then graph the result to get an idea of
where the values are converging to:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{f}\NormalTok{(x) }\OperatorTok{=}\NormalTok{ x}\OperatorTok{\^{}}\FloatTok{2}
\FunctionTok{δfδx}\NormalTok{(x, δx) }\OperatorTok{=}\NormalTok{ (}\FunctionTok{f}\NormalTok{(x }\OperatorTok{+}\NormalTok{ δx) }\OperatorTok{{-}} \FunctionTok{f}\NormalTok{(x))}\OperatorTok{/}\NormalTok{δx }\CommentTok{\# The approximate derivative δf/δx at x}

\FunctionTok{plot}\NormalTok{(}
    \FunctionTok{Float16}\NormalTok{(}\FloatTok{0.0001}\NormalTok{)}\OperatorTok{:}\FunctionTok{Float16}\NormalTok{(}\FloatTok{0.0001}\NormalTok{)}\OperatorTok{:}\FunctionTok{Float16}\NormalTok{(}\FloatTok{0.1}\NormalTok{),}
\NormalTok{    δx }\OperatorTok{{-}\textgreater{}} \FunctionTok{δfδx}\NormalTok{(}\FloatTok{1}\NormalTok{, δx), }\CommentTok{\# Don\textquotesingle{}t need to specify 1 as Float16 because of multiple dispatch}
\NormalTok{    legend }\OperatorTok{=} \ConstantTok{false}\NormalTok{,}
\NormalTok{    xlabel }\OperatorTok{=} \StringTok{"δx"}\NormalTok{,}
\NormalTok{    ylabel }\OperatorTok{=} \StringTok{"δf/δx at x = 1"}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/basics/numeric-types/numeric-types_files/figure-pdf/cell-38-output-1.pdf}

}

\end{figure}

Looking from the right, we can see that the line, although jagged, is
roughly converging in on the correct value of \texttt{2}. But as we get
closer to \texttt{0}, the line becomes increasingly jagged, and stops
converging entirely. What's happened?

The problem comes when calculating \texttt{f(1\ +\ δx)\ -\ f(1)}, and is
twofold. Firstly, let's consider what value \texttt{1\ +\ δx} really
takes. We can use the \texttt{nextfloat} function to tell us what the
next representable number after the input is:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nextfloat}\NormalTok{(}\FunctionTok{Float16}\NormalTok{(}\FloatTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Float16(1.001)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nextfloat}\NormalTok{(}\FunctionTok{Float16}\NormalTok{(}\FloatTok{1.001}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Float16(1.002)
\end{verbatim}

Herein lies the first issue. While the floating-point representations of
\texttt{0.0001}, \texttt{0.0002}, \texttt{0.0003}, etc. are distinct,
the density of floating-point numbers is greatly decreased as we go away
from \texttt{0}, and so the floating-point representations of
\texttt{1.0001}, \texttt{1.0002}, \texttt{1.0003}, etc. are not
distinct. We can demonstrate by calculating the first twenty of these
values:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{collect}\NormalTok{((}\FunctionTok{Float16}\NormalTok{(}\FloatTok{0.0001}\NormalTok{)}\OperatorTok{:}\FunctionTok{Float16}\NormalTok{(}\FloatTok{0.0001}\NormalTok{)}\OperatorTok{:}\FunctionTok{Float16}\NormalTok{(}\FloatTok{0.002}\NormalTok{)) }\OperatorTok{.+} \FloatTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
20-element Vector{Float16}:
 1.0
 1.0
 1.0
 1.0
 1.001
 1.001
 1.001
 1.001
 1.001
 1.001
 1.001
 1.001
 1.001
 1.001
 1.002
 1.002
 1.002
 1.002
 1.002
 1.002
\end{verbatim}

There simply aren't enough possible \texttt{Float16} numbers to
differentiate these values! This is an example of adding together
numbers of different magnitudes, namely adding \texttt{1} to numbers
between 1000 and 10000 times smaller.

A measure of the required magnitude difference needed for such
inaccuracy is given by the \emph{machine epsilon}
\(\varepsilon_\mathrm{mach}\). This is a property of each data type,
given by \(\varepsilon_\mathrm{mach} = 2^{-d}\), where the mantissa is
represented by \(d\) bits. In the case of \texttt{Float16}, \(d = 10\),
so \(\varepsilon_\mathrm{mach} = 2^{-10} \approx 0.001\), which agrees
with our observations. For \texttt{Float64},
\(\varepsilon_\mathrm{mach} = 2^{-52} \approx 2 \times 10^{-16}\), which
for many purposes is too small to care about, but it's large enough that
many algorithms using floating-point arithmetic have to be adapted to
avoid it.

However, in our case, for the moment, the relative errors remain quite
small, as we're still only differing in the fourth significant figure
from the intended value. The problem only becomes visible when we square
these values (i.e.~calculating \texttt{f(1\ +\ δx)}) and subtract
\texttt{f(1)\ =\ 1}.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.1370}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.4795}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3836}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\texttt{δx}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Exact value of \texttt{f(1\ +\ δx)\ -\ f(1)}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\texttt{Float16} calculated value
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\(0.0001\) & \(0.00020001\) & \texttt{0.0} \\
\(0.0002\) & \(0.00040004\) & \texttt{0.0} \\
\(0.0003\) & \(0.00060009\) & \texttt{0.0} \\
\(0.0004\) & \(0.00080016\) & \texttt{0.0} \\
\(0.0005\) & \(0.00100025\) & \texttt{0.001953} \\
\(0.0006\) & \(0.00120036\) & \texttt{0.001953} \\
\(0.0007\) & \(0.00140049\) & \texttt{0.001953} \\
\(0.0008\) & \(0.00160064\) & \texttt{0.001953} \\
\(0.0009\) & \(0.00180081\) & \texttt{0.001953} \\
\(0.001\) & \(0.002001\) & \texttt{0.001953} \\
\end{longtable}

Note that \texttt{0.001953} is just an approximation to the real value,
which is \texttt{0.001953125}. Now, the largest significant figures are
cancelled, and what was before a difference in the fourth significant
figure is now a difference in the first! What were once errors of a
fraction of a percent are now numbers twice as big as they should be (or
in some cases, 0 for non-zero numbers).

To avoid this, we need to be aware of the machine epsilon and the limit
it places on the accuracy of computations, an inevitability of the way
that floating-point numbers are defined. The only way to get around it
if you need to do such calculations with floating-point numbers is to
increase the precision (e.g.~from \texttt{Float16} to \texttt{Float32}
or \texttt{Float64}), increasing the length of the mantissa, and
decreasing the machine epsilon.

\hypertarget{special-exponents-00...0-and-11...1}{%
\subsection{\texorpdfstring{Special exponents \texttt{00...0} and
\texttt{11...1}}{Special exponents 00...0 and 11...1}}\label{special-exponents-00...0-and-11...1}}

There is one more quirk to floating-point numbers that we've eluded to,
but not yet mentioned, and that is the numbers with exponent bits all
\texttt{0} or all \texttt{1}. These not only extend the ability of
floating-point numbers, but allow deal with the issues of overflow and
underflow which we met in the integer case earlier.

A glaring issue in our current implementation of \texttt{Float16} is
that there is no \texttt{0}, since it doesn't really \emph{have}
significant figures. It would also seem sensible (although by no means
necessary) to have the bit string \texttt{"0000000000000000"} represent
\texttt{0}, but if the exponent \texttt{00000} worked like the rest,
then this number would be \(+1.0000000000_2 \times 2^{-15} = 2^{-15}\),
since the implied bit \texttt{1} as the first significant figure.
Instead, when the exponent is \texttt{00000}, we keep the shift of
\(-14\) like \texttt{00001}, but take the implied bit to be \texttt{0}
instead of \texttt{1}. Therefore, the all zeroes bit string is
interpreted as \(+0.000000000000_2 \times 2^{-14} = 0\).

Keeping the exponent \texttt{00000}, if we change some of the mantissa
bits to be non-zero, then we get smaller positive numbers than we could
represent before, such as \texttt{"0000000101011011"} representing
\(+0.0101011011_2 \times 2^{-14} \approx 0.0000207\). Such numbers are
called \emph{subnormal} numbers, as opposed to the \emph{normal} numbers
that we've seen before with other exponents. While it is very useful to
have such numbers available for calculation, the initial zero means that
they have many fewer significant digits than normal floating-point
numbers, and so are even more prone to calculation errors.

Of course, this works the same with sign bit \texttt{1}, giving us all
the same numbers but with a minus sign. In particular, the bit string
\texttt{"1000000000000000"} gives the number \texttt{-0}, which is
actually different from \texttt{0}. So now, instead of no \texttt{0},
we've got two! If we return to thinking about intervals instead of exact
values, then this seems less ridiculous, with \texttt{0} encompassing
all positive numbers that are too small to represent with even the
smallest subnormal number, and similarly \texttt{-0} for their negative
counterparts.

Meanwhile, the exponent \texttt{11111} works in an entirely different
way, in fact it doesn't really act as an exponent at all. Rather, it
marks out three special values that complete floating-point arithmetic:

\begin{itemize}
\item
  Adding the mantissa \texttt{"0000000000"} gives the bit string
  \texttt{"0111110000000000"}, which represents the value
  \texttt{Inf16}, or positive infinity. As a range, it is better thought
  of as all the numbers too big to represent as a \texttt{Float16}
  (specifically everything that is at least \(65520\))
\item
  With the sign bit flipped, the bit string
  \texttt{"1111110000000000000"} represents the value \texttt{-Inf16},
  or negative infinity (or the range of all numbers at most \(-65520\))
\item
  Any other mantissa gives the value \texttt{NaN16}, which stands for
  \emph{``not a number''}. This means that Julia has no idea what answer
  to give to your calculation
\end{itemize}

While these are not numbers in the usual sense, they are floating-point
values, and we can do arithmetic with them, for example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Float16}\NormalTok{(}\FloatTok{1}\NormalTok{)}\OperatorTok{/}\FunctionTok{Float16}\NormalTok{(}\FloatTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Inf16
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Float16}\NormalTok{(}\FloatTok{1}\NormalTok{)}\OperatorTok{/{-}}\ConstantTok{Inf16}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Float16(-0.0)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Float16}\NormalTok{(}\FloatTok{0}\NormalTok{)}\OperatorTok{*}\ConstantTok{Inf16}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
NaN16
\end{verbatim}

More or less any arithmetic you do with \texttt{NaN16} will return
\texttt{NaN16}, because Julia doesn't have a value to calculate with.
There are some odd exceptions where the value of the number is
irrelevant, such as:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{1}\OperatorTok{\^{}}\ConstantTok{NaN16}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Float16(1.0)
\end{verbatim}

The same works for \texttt{Float32} and \texttt{Float64}, with the
exponent of \texttt{00...0} being the same as that of \texttt{00...01},
but with implied bit \texttt{0} instead of \texttt{1}. Also, as
\texttt{Float64} is the default, the infinite and not-a-number values
are simply \texttt{Inf}, \texttt{-Inf} and \texttt{NaN} (although you
can type in \texttt{NaN64} if you like, but Julia will display
\texttt{NaN}).

\hypertarget{bigfloat}{%
\subsection{\texorpdfstring{\texttt{BigFloat}}{BigFloat}}\label{bigfloat}}

The other floating-point type is \texttt{BigFloat}, which much like
\texttt{BigInt}, allows for floating-point numbers to be stored with
more bits, and therefore more precision. However, unlike
\texttt{BigInt}, there are decimals that we can write down easily but
can't be represented exactly by \texttt{BigFloat}. For example, as we've
already noted, the decimal \(0.1\) is represented in binary as
\texttt{0.0001100110011...}, with infinitely many binary digits. Unless
your computer has infinite memory (unlikely), it's clearly impossible to
store this exactly as a floating-point number, so instead
\texttt{BigFloat} simply allows you to increase the level of precision
(i.e.~the number of mantissa bits, plus one for the implied first bit
\texttt{1}) as you please, with the exponent stored exactly as an
\texttt{Int32}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{BigFloat}\NormalTok{(}\StringTok{"0.1"}\NormalTok{, precision }\OperatorTok{=} \FloatTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.099976
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{BigFloat}\NormalTok{(}\StringTok{"0.1"}\NormalTok{, precision }\OperatorTok{=} \FloatTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.10000000000000000000000000000002
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{BigFloat}\NormalTok{(}\StringTok{"0.1"}\NormalTok{, precision }\OperatorTok{=} \FloatTok{1000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002
\end{verbatim}

Note that we have to input the number \texttt{0.1} as a string
\texttt{"0.1"}, since otherwise Julia will read it as a \texttt{Float64}
immediately and immediately round it to \texttt{53} bit precision.

\hypertarget{parametric-number-types}{%
\section{Parametric number types}\label{parametric-number-types}}

The various \texttt{Integer} and \texttt{Float} types are by far the
most used types, but the others on the diagram are useful in certain
circumstances, and for completeness, we'll look at all of them. All
three are \emph{parametric} types, which means that they require another
type as a parameter before they can become a concrete type and take
values.

\hypertarget{complex}{%
\subsection{\texorpdfstring{\texttt{Complex}}{Complex}}\label{complex}}

The \texttt{Complex} type is, unsurprisingly, used for dealing with
complex numbers. The imaginary constant in Julia is called \texttt{im}
(since \texttt{i} is so commonly used as an index for iteration in
loops, see Chapter~\ref{sec-controlflow}), with complex numbers given by
multiplying this by the desired imaginary part and adding the real part:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OperatorTok{=} \FloatTok{1} \OperatorTok{+} \FloatTok{4}\OperatorTok{*}\ConstantTok{im}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1 + 4im
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(z)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Complex{Int64}
\end{verbatim}

We see here that the type is not just \texttt{Complex}, but
\texttt{Complex\{Int64\}}. This means \texttt{Complex} where the real
and imaginary parts are of type \texttt{Int64}. We can do this with any
\texttt{Real} type:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Float16}\NormalTok{(}\FloatTok{0.4}\NormalTok{) }\OperatorTok{+} \FunctionTok{Float16}\NormalTok{(}\FloatTok{0.6}\NormalTok{)}\OperatorTok{*}\ConstantTok{im}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Float16(0.4) + Float16(0.6)im
\end{verbatim}

We can even mix-and-match, and Julia will choose the best data type to
represent both. Here, \texttt{1} is of type \texttt{Int64}, but
\texttt{3.5} is of type \texttt{Float64}, and Julia knows to pick
\texttt{Float64} to represent both, as we can see by the addition of
\texttt{.0} to the end.

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{1} \OperatorTok{+} \FloatTok{3.5}\OperatorTok{*}\ConstantTok{im}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1.0 + 3.5im
\end{verbatim}

Complex arithmetic is fully implemented with such types, although the
same quirks of floating-point arithmetic crop up when the type parameter
is one of the \texttt{Float} types.

\hypertarget{rational}{%
\subsection{\texorpdfstring{\texttt{Rational}}{Rational}}\label{rational}}

The \texttt{Rational} type allows for fractions to be stored and
calculated with exact numerators and denominators, avoiding the
precision issues of floating-point arithmetic. Again, this is a
parametric type, but this type the parameter must be an \texttt{Integer}
type, as it is the type that the numerator and denominator will take.

Rationals are constructed using the operation \texttt{//}, separating
the numerator and the denominator:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{12} \OperatorTok{//} \FloatTok{15}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4//5
\end{verbatim}

Note that the numerator and denominator are automatically cancelled to
the lowest terms. In this case, with \texttt{Rational\{Int64\}}s, this
is good, since we want to keep the numerator and denominator as small as
possible to avoid issues with overflows and underflows that we saw
earlier. Such errors still exist, although they will be identified and
give an error message instead of being calculated:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typemax}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{)}\OperatorTok{//}\FloatTok{1} \OperatorTok{+} \FloatTok{1}\OperatorTok{//}\FloatTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: OverflowError: 9223372036854775807 + 1 overflowed for type Int64
\end{verbatim}

For maximal precision, we can convert the numerator and denominator to
\texttt{BigInt} form, which can (inefficiently) store arbitrarily large
rational numbers with no error. This can be preferable to using
floating-point numbers in instances where precision is more important
than speed.

\hypertarget{irrational}{%
\subsection{\texorpdfstring{\texttt{Irrational}}{Irrational}}\label{irrational}}

The final numeric type on the diagram is \texttt{Irrational}, and it's
special, because while it's a parametric type, the parameter is not the
name of another type. Instead, it's a \texttt{Symbol}, which is a type
that represents variable names. The most familiar example is the
constant \texttt{π}, which is represented by the \texttt{Symbol}
\texttt{:π} (the colon denotes that the following word should be treated
as a \texttt{Symbol} and not a variable name), and so has type
\texttt{Irrational\{:π\}}:

\begin{Shaded}
\begin{Highlighting}[]
\ConstantTok{π}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
π = 3.1415926535897...
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\ConstantTok{π}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Irrational{:π}
\end{verbatim}

The main purpose of \texttt{Irrational} types is for multiple dispatch.
Irrational numbers such as \texttt{π} can't be represented exactly by
floating-point types, and if the floating-point approximation is used
instead of the exact value, the answer of calculations may be wrong. For
example, \texttt{sin(π)} should exactly equal \texttt{0}, but if we were
to first approximate \texttt{π} by a floating-point number, we don't get
\texttt{0}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sin}\NormalTok{(}\FunctionTok{Float64}\NormalTok{(}\ConstantTok{π}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1.2246467991473532e-16
\end{verbatim}

The \texttt{Irrational} type fixes this by defining a method for an
input of type \texttt{Irrational\{:π\}}, with output exactly \texttt{0}
(or more specifically, the \texttt{Float64} value \texttt{0.0}):

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{Base}\NormalTok{.}\FunctionTok{sin}\NormalTok{(}\OperatorTok{::}\DataTypeTok{Irrational\{:π\}}\NormalTok{) }\OperatorTok{=} \FloatTok{0.0} \CommentTok{\# From https://github.com/JuliaLang/julia/blob/master/base/mathconstants.jl}
\end{Highlighting}
\end{Shaded}

This overrides the usual method for computing \texttt{sin} of a
\texttt{Float64}, and we get:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sin}\NormalTok{(}\ConstantTok{π}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.0
\end{verbatim}

For any other calculation where an exact answer is not specified, the
irrational number will be treated just like its \texttt{Float64}
approximation as normal.

\hypertarget{resolving-problems}{%
\section{Resolving problems}\label{resolving-problems}}

It's all very well knowing why these arithmetic errors are happening,
but what can we do to avoid them? The first thing you should ask
yourself is whether it is worth the effort to avoid them. Sometimes,
errors will exist, but are too small to care about, or won't
realistically happen, and the easy solution of simply ignoring them is
the best way to go.

However, as we've seen, sometimes such errors become a genuine issue,
and it's worth knowing about some of the features that Julia has resolve
them. We'll return to the examples we saw at the start, and see that
they were carefully picked to be able to be solved neatly and concisely.

To begin with, we tried adding \texttt{0.1} and \texttt{0.2}. Because
these don't have exact floating-point representations, and neither does
their sum, we got \texttt{0.30000000000000004} instead of \texttt{0.3}.
If we use \texttt{Rational}s instead (specifically
\texttt{Rational\{Int64\}}s), then the addition will be done exactly.

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{1}\OperatorTok{//}\FloatTok{10} \OperatorTok{+} \FloatTok{1}\OperatorTok{//}\FloatTok{5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3//10
\end{verbatim}

If we wish to convert to a \texttt{Float64} afterwards, we can do, and
the answer will be correct:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Float64}\NormalTok{(}\FloatTok{1}\OperatorTok{//}\FloatTok{10} \OperatorTok{+} \FloatTok{1}\OperatorTok{//}\FloatTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.3
\end{verbatim}

Note that we can't go back in the other direction, trying to convert the
\texttt{Float64} \texttt{0.1} to a \texttt{Rational} gives:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Rational}\NormalTok{(}\FloatTok{0.1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3602879701896397//36028797018963968
\end{verbatim}

This is the exact floating-point value that is stored as a best
approximation to \texttt{0.1}, but is clearly not equal to \texttt{0.1},
so some error would remain if we tried to calculate with this.

How about raising \texttt{2} to the power \texttt{100}? This time, the
error was an integer overflow error, because \texttt{2} is an
\texttt{Int64}, but raising it to the power \texttt{100} gives more than
\texttt{typemax(Int64)}, which is \(2^{63} - 1 = 9223372036854775807\).
Instead, it overflows, and wraps back around to \(0\) every \(2^{64}\).
Due to the repeated squaring algorithm that Julia uses to calculate such
exponentials, it ends up calculating
that\(2^{100} = 2^{64} \times 2^{32} \times 2^{4} = 0 \times 4294967296 \times 16 = 0\).
In this case, \texttt{Int128} will be enough to handle this big a number
(although \texttt{BigInt} would also work), and we only need to convert
the \texttt{2} to be an \texttt{Int128}, as raising this to the power
\texttt{100} will automatically be understood as a operation on a
\texttt{Int128}, and will return a \texttt{Int128}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Int128}\NormalTok{(}\FloatTok{2}\NormalTok{)}\OperatorTok{\^{}}\FloatTok{100}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1267650600228229401496703205376
\end{verbatim}

Finally, why can Julia correctly calculate \texttt{cos(π)}, but not
\texttt{cos(π/2)}? The \texttt{cos} function has a special method to
specifically calculate \texttt{cos(π)} correctly, just as \texttt{sin}
did, since \texttt{π} has its own type \texttt{Irrational\{:π\}}.
However, \texttt{π/2} does not have such a type, in fact it's not even
\texttt{Irrational} type -- it is the output of the \texttt{/} function
of types \texttt{Irrational\{:π\}} and \texttt{Int64}, which is
\texttt{Float64} as that is the best approximation that exists. This
means that its value is not exact, and this floating-point error is
carried through when taking the cosine. We can demonstrate this by
making use of the \texttt{@which} macro, which tells us which method
Julia is using to calculate the final answer:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{@which} \FunctionTok{cos}\NormalTok{(}\ConstantTok{π}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
cos(::Irrational{:π})
     @ Base.MathConstants mathconstants.jl:127
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{@which} \FunctionTok{cos}\NormalTok{(}\ConstantTok{π}\OperatorTok{/}\FloatTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
cos(x::T) where T<:Union{Float32, Float64}
     @ Base.Math special\trig.jl:98
\end{verbatim}

To remedy this, Julia provides us with a function specifically for
calculating the cosine of multiples of \texttt{π}, called \texttt{cospi}
(similar functions such as \texttt{sinpi}, \texttt{sincospi}, and
\texttt{cispi} also exist). We can see that this works as expected:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cospi}\NormalTok{(}\FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.0
\end{verbatim}

\hypertarget{sec-strings}{%
\chapter{Representing text}\label{sec-strings}}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-important-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Prerequisites}, colframe=quarto-callout-important-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Before reading this chapter, you are recommended to have read
Chapter~\ref{sec-fundamentals}.

\end{tcolorbox}

\hypertarget{chars-and-strings}{%
\section{\texorpdfstring{\texttt{Char}s and
\texttt{String}s}{Chars and Strings}}\label{chars-and-strings}}

\hypertarget{special-characters}{%
\section{Special characters}\label{special-characters}}

\hypertarget{the-and-operators}{%
\section{\texorpdfstring{The \texttt{*} and \texttt{\^{}}
operators}{The * and \^{} operators}}\label{the-and-operators}}

\hypertarget{string-interpolation}{%
\section{String interpolation}\label{string-interpolation}}

\hypertarget{indexing-strings}{%
\section{\texorpdfstring{Indexing
\texttt{String}s}{Indexing Strings}}\label{indexing-strings}}

\hypertarget{sec-controlflow}{%
\chapter{Control flow}\label{sec-controlflow}}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-important-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Prerequisites}, colframe=quarto-callout-important-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Before reading this chapter, you are recommended to have read
Chapter~\ref{sec-fundamentals}.

\end{tcolorbox}

In most books, the \emph{flow} is very simple, you simply read page by
page in order from front to back. However, this is not always the case.
A detective novel may have you flicking back and forth referring to
clues cleverly hidden in earlier dialogue, an encyclopedia may consist
of several sections which can be read in any order, and a
choose-your-own-adventure book will explicitly direct you across its
pages following your chosen path. These are all an analogy to the
programming concept of \emph{control flow}, that is mechanisms to make
your program run in a way other than straight down the page line by
line.

While a simple enough idea, the power of this is immense. With a few
simple words, we can add branching paths, repeat code, or automatically
detect problems and raise exceptions. Not only does this broaden the
computations we are able to do, in fact it can be argued that simply the
addition of loops and conditionals to a programming language give all
the computational power we need, by making the language
\emph{Turing-complete}. Everything else we add to the language are just
shortcuts to save us time. With that in mind, let's begin, with
\texttt{begin}.

\hypertarget{begin-end}{%
\section{\texorpdfstring{\texttt{begin}-\texttt{end}}{begin-end}}\label{begin-end}}

In Julia, the line break is simple enough syntax, that you may even
ignore its importance. Indeed, in the REPL, pressing \texttt{Enter\ ⮠}
doesn't just give a new line, it executes the previous as code too. In a
script file, each line is executed one at a time. However, sometimes,
there are calculations that are written as several lines of code, but we
really want to run as a block. For example, suppose that we run the
following two lines of code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \FloatTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+} \FloatTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
\end{verbatim}

This initialises the variable \texttt{a} as \texttt{1}, then changes the
value of \texttt{a} by adding \texttt{1} to the previous value of
\texttt{a}, i.e.~\texttt{1\ +\ 1\ =\ 2}. If we want to run this program
again, we need to make sure that the individual lines are evaluated in
the right order. If not (for example if we use \texttt{↑} and \texttt{↓}
in the REPL to rerun previous lines), we could get a different result:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+} \FloatTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \FloatTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

We now add \texttt{1} to \texttt{a} as before, but the current value of
\texttt{a} is \texttt{2}, so we get \texttt{3}. Then, this is
overwritten with the initial value \texttt{1}, so we end up with
\texttt{1} as a final answer.

This seems a pretty trivial example, but it demonstrates that the order
of lines of code is important, and that there may be reason to group
lines of code together in a fixed order that cannot be changed.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Convention}, colframe=quarto-callout-tip-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Lines of code grouped together in such a way should be indented (using
\texttt{Tab\ ⇆} or several spaces) relative to the code around them, to
emphasise them as a collection. This is done for all of the
\emph{blocks} that we use here, as demonstrated in the example code.

\end{tcolorbox}

The \texttt{begin}-\texttt{end} block is the simplest example of such a
block, and also the simplest example of control flow in Julia. The
syntax is equally straightforward: we start with the keyword
\texttt{begin}, on a new line start writing the lines of code we want to
enclose, and finish with \texttt{end} on a final line:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{begin}
\NormalTok{    a }\OperatorTok{=} \FloatTok{1}
\NormalTok{    a }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+} \FloatTok{1}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
\end{verbatim}

By enclosing this code in a block, it is treated as one line of code, so
we can't possibly run it in the wrong order. In this sense, it is like a
set of parentheses in algebra, grouping together calculations that would
normally be done seperately. Much like a set of parentheses, we can also
nest many blocks inside each other (indeed, we will want to do this in
certain cases, although sometimes it can get a little messy), so we need
to make sure that each block has a corresponding \texttt{end} codeword.

\hypertarget{conditionals}{%
\section{Conditionals}\label{conditionals}}

Probably the most widely applicable of all of the structures we look at
here, conditionals provide the means to change the behaviour based on
whether a condition is met or not. First, we'll examine what we mean by
a condition in Julia.

\hypertarget{examples-of-conditions}{%
\subsection{Examples of conditions}\label{examples-of-conditions}}

Conditions come in many forms, but in general they will be a function
(including infix operators such as ``\textless{}'') that return a
\texttt{Bool} value. For example, we have the infix operators:

\begin{itemize}
\tightlist
\item
  Equality of two values can be checked by \texttt{==}. This is a
  \emph{smart} equality, in that it can return \texttt{true} even if the
  same value is represented in two different ways (such as the
  \texttt{Int64} \texttt{0} and the \texttt{Float64} \texttt{0.0})
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{5} \OperatorTok{==} \FloatTok{6}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
false
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Identicality is checked by \texttt{===}, i.e.~is the data on either
  side stored identically as bits. \texttt{0\ ===\ 0.0} returns
  \texttt{false}, since although the values are mathematically the same,
  they are represented in two different formats
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{0} \OperatorTok{==} \FloatTok{0.0}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{0} \OperatorTok{===} \FloatTok{0.0}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
false
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Inequalities \texttt{\textless{}} and \texttt{\textgreater{}} work
  exactly as you'd expect for numeric values, with \texttt{\textless{}=}
  and \texttt{\textgreater{}=} (or indeed \texttt{≤} and \texttt{≥})
  including the equality case as well. They have different behaviours on
  other types, for example \texttt{String}s are compared against
  alphabetical order
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{3} \OperatorTok{\textgreater{}} \FloatTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
false
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"apple"} \OperatorTok{≤} \StringTok{"banana"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Conditions can be combined together with
  \href{https://en.wikipedia.org/wiki/Logic_gate}{logical operators},
  such as \texttt{\&\&} for \texttt{AND} and
  \texttt{\textbar{}\textbar{}} for \texttt{OR} (these aren't
  technically functions, but \texttt{Core} Julia syntax)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{3} \OperatorTok{\textgreater{}} \FloatTok{4} \OperatorTok{\&\&} \StringTok{"apple"} \OperatorTok{≤} \StringTok{"banana"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
false
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{3} \OperatorTok{\textgreater{}} \FloatTok{4} \OperatorTok{||} \StringTok{"apple"} \OperatorTok{≤} \StringTok{"banana"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{itemize}
\tightlist
\item
  When evaluated on two types, the \texttt{\textless{}:} operator checks
  if the first type is inherits from the second type (i.e.~below it in
  the type graph, see Chapter~\ref{sec-multipledispatch} for more
  details on this)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{Float64} \OperatorTok{\textless{}:}\DataTypeTok{ Number}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{Float64} \OperatorTok{\textless{}:}\DataTypeTok{ Integer}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
false
\end{verbatim}

\begin{itemize}
\tightlist
\item
  The function \texttt{isa} can be used as an infix operator, checking
  if the value on the left can be interpreted as the type on the right
  (\texttt{x\ isa\ T} can be thought of as
  \texttt{typeof(x)\ \textless{}:\ T})
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{5}\NormalTok{ isa }\DataTypeTok{Number}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{isa}\NormalTok{(}\FloatTok{5}\NormalTok{, }\DataTypeTok{Number}\NormalTok{) }\CommentTok{\# Equivalently, in more usual function syntax}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

Like \texttt{isa}, other functions can behave as conditions, in fact any
function that returns a \texttt{Bool} value will do, of which Julia
provides many (often with names beginning with \texttt{is}). Some
examples are:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{isinteger}\NormalTok{(}\FloatTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{islowercase}\NormalTok{(}\CharTok{\textquotesingle{}α\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{isabstracttype}\NormalTok{(}\DataTypeTok{Real}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{!(}\ConstantTok{false}\NormalTok{) }\CommentTok{\# Boolean NOT, sends true to false and false to true}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

We'll now see how we can put these conditions to use.

\hypertarget{if-statements}{%
\subsection{\texorpdfstring{\texttt{if}-statements}{if-statements}}\label{if-statements}}

An \texttt{if} statement begins with the keyword \texttt{if}, followed
by a condition. If the value of the condition is \texttt{true}, then the
block of code following \texttt{if} will be run, and if the value is
\texttt{false}, the code won't be run. As with
\texttt{begin}-\texttt{end}, the block of code following \texttt{if}
starts on the next line, and can be stopped with the keyword
\texttt{end}.

We can also give some alternative code to be run if the condition is not
met, using the keyword \texttt{else}. This serves a dual purpose,
marking the end of the code block after \texttt{if} just like
\texttt{end}, but also marking the start of a new code block. This can
be seen in the example below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \FloatTok{5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \FunctionTok{iseven}\NormalTok{(x)}
    \FunctionTok{print}\NormalTok{(}\StringTok{"Even!"}\NormalTok{)}
\ControlFlowTok{else}
    \FunctionTok{print}\NormalTok{(}\StringTok{"Odd!"}\NormalTok{)}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Odd!
\end{verbatim}

You may also want to add further conditions, which can be done with
\texttt{elseif}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textless{}} \FloatTok{0}
    \FunctionTok{print}\NormalTok{(}\StringTok{"Negative!"}\NormalTok{)}
\ControlFlowTok{elseif}\NormalTok{ x }\OperatorTok{\textgreater{}} \FloatTok{0}
    \FunctionTok{print}\NormalTok{(}\StringTok{"Positive!"}\NormalTok{)}
\ControlFlowTok{else}
    \FunctionTok{print}\NormalTok{(}\StringTok{"Zero!"}\NormalTok{)}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Positive!
\end{verbatim}

\hypertarget{short-circuited-and}{%
\subsection{\texorpdfstring{Short-circuited \texttt{\&\&} and
\texttt{\textbar{}\textbar{}}}{Short-circuited \&\& and \textbar\textbar{}}}\label{short-circuited-and}}

In Julia, the \texttt{AND} (\texttt{\&\&}) and \texttt{OR}
(\texttt{\textbar{}\textbar{}}) operators have an optimisation called
\emph{short-circuiting}, allowing for more efficient code:

\begin{itemize}
\item
  Consider the statement \texttt{x\ \&\&\ y}. If \texttt{x} is
  \texttt{false}, then there is no need to evaluate \texttt{y}, since
  the overall result will always be \texttt{false}, so Julia
  short-circuits by ignoring it and simply returning \texttt{false}
\item
  Similarly, in the case \texttt{x\ \textbar{}\textbar{}\ y} with
  \texttt{x} true, the overall result will be true without checking
  \texttt{y}
\end{itemize}

This is why \texttt{\&\&} and \texttt{\textbar{}\textbar{}} aren't
functions, because functions don't allow this behaviour, and it is a
decent optimisation in certain cases. However, Julia allows us to do
even more, as \texttt{y} doesn't need to be a condition, in fact it can
be any code at all. It will then only get executed if the \texttt{\&\&}
or \texttt{\textbar{}\textbar{}} is not short-circuited, as we see
below:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{3} \OperatorTok{\textgreater{}} \FloatTok{4} \OperatorTok{\&\&} \FunctionTok{print}\NormalTok{(}\StringTok{"Secret message"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
false
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{3} \OperatorTok{\textless{}} \FloatTok{4} \OperatorTok{\&\&} \FunctionTok{print}\NormalTok{(}\StringTok{"Secret message"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Secret message
\end{verbatim}

This could instead be written as a very short \texttt{if} statement:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \FloatTok{3} \OperatorTok{\textgreater{}} \FloatTok{4}
    \FunctionTok{print}\NormalTok{(}\StringTok{"Secret message"}\NormalTok{)}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \FloatTok{3} \OperatorTok{\textless{}} \FloatTok{4}
    \FunctionTok{print}\NormalTok{(}\StringTok{"Secret message"}\NormalTok{)}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Secret message
\end{verbatim}

\hypertarget{the-ternary-operator}{%
\subsection{\texorpdfstring{The ternary operator
\texttt{?\ :}}{The ternary operator ? :}}\label{the-ternary-operator}}

As well as the above, another common short \texttt{if} statements is to
choose between two values by a condition. For example, the following is
an equivalent way to write \texttt{y\ =\ max(0,x)}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OperatorTok{=} \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textless{}} \FloatTok{0}
    \FloatTok{0}
\ControlFlowTok{else}
\NormalTok{    x}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5
\end{verbatim}

The ternary operator is a way to reduce this to one line. We follow the
condition by a question mark \texttt{?}, and then give the value if the
condition holds and the value if it doesn't, seperating them with a
colon \texttt{:}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OperatorTok{=}\NormalTok{ (x }\OperatorTok{\textless{}} \FloatTok{0}\NormalTok{) ? }\FloatTok{0} \OperatorTok{:}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5
\end{verbatim}

Of course, in this example, we already had a way of doing the same thing
in one line (\texttt{y\ =\ max(0,x)}), but in more complex cases this
can be very valuable.

You may wonder what was wrong with the longer \texttt{if}-statements,
and why we would need to replace them. The answer is that there isn't
really anything wrong, but it's additional syntax that we can use to
more quickly and easily do common tasks. The other extreme would be that
we'd have very little syntax in the language, which would be easy to
learn, but more difficult to master, as anything more than the simplest
task would require strong familiarity with the few tools at your
disposal to get the most out of them. This isn't necessarily a bad
thing, but it's not the way that Julia works.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Convention}, colframe=quarto-callout-tip-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Short-circuiting and the ternary operator should both be used in
preference to \texttt{if} where possible for short conditionals. Longer
conditional statements (for example where multiple lines of code need to
be run depending on the outcome of the condition) should use
\texttt{if}, as it can get messy with the compact forms.

\end{tcolorbox}

We now have the means of changing the behaviour of a program depending
on whether a condition is met. The other thing that we'd like to be able
to do for Turing completeness (and just in general) is repeat the same
code multiple times, such that we don't have to write it out again and
again, which is achieved by \emph{loops}.

\hypertarget{loops}{%
\section{Loops}\label{loops}}

\hypertarget{while}{%
\subsection{\texorpdfstring{\texttt{while}}{while}}\label{while}}

Julia offers two options for loops, the first of which is the
\texttt{while} loop. This executes the same block of code again and
again, but at the start of each iteration, it checks a condition that is
put the loop. If the condition is \texttt{true}, the loop continues, and
if the condition is \texttt{false}, the loop is broken, and the program
continues past the \texttt{while} block. This is obviously very
desirable, we most likely don't want to be stuck repeating the same code
indefinitely. Also, we'll want to make use of variables whose values we
can change, allowing the condition to be true for some time until we
choose it to be false and the loop to stop.

A \texttt{while} block starts with \texttt{while}, followed by a
condition, much like the \texttt{if}-statements we saw before. The block
of code to be repeated then begins on the next line, and lasts until the
\texttt{end} codeword just like any other block. An example is shown
below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OperatorTok{=} \FloatTok{0}
\NormalTok{c }\OperatorTok{=} \FloatTok{0.3}
\NormalTok{iterations }\OperatorTok{=} \FloatTok{0}

\CommentTok{\# Keeps going if z has absolute value less than 2, and iterations is less than 100}
\ControlFlowTok{while}\NormalTok{ (}\FunctionTok{abs}\NormalTok{(z) }\OperatorTok{\textless{}} \FloatTok{2}\NormalTok{) }\OperatorTok{\&\&}\NormalTok{ (iterations }\OperatorTok{\textless{}} \FloatTok{100}\NormalTok{)}
\NormalTok{    z }\OperatorTok{=}\NormalTok{ z}\OperatorTok{\^{}}\FloatTok{2} \OperatorTok{+}\NormalTok{ c}
    \CommentTok{\# Shorthand, means "add 1 to the variable iterations"}
    \CommentTok{\# Equivalent to "iterations = iterations + 1"}
\NormalTok{    iterations }\OperatorTok{+=} \FloatTok{1}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\hypertarget{for}{%
\subsection{\texorpdfstring{\texttt{for}}{for}}\label{for}}

The other type of loop in Julia is a \texttt{for} loop, which runs the
same code for each element in some kind of collection. Collections come
in many forms, for instance \texttt{String}s are a collection of
\texttt{Char}s, or ranges of numbers such as \texttt{1:10} meaning the
numbers from \texttt{1} to \texttt{10}. We investigate more of these in
Chapter~\ref{sec-arrays}.

To iterate through the collection, we need to give a variable name to
represent the element we choose from the array, such as \texttt{n} in
the example below. Then, we can write the \texttt{for} loop, by starting
with the keyword \texttt{for}, followed in turn by the chosen variable
name, the keyword \texttt{in} (or the symbol \texttt{∈}, written by
tab-completing \texttt{\textbackslash{}in}, or simply \texttt{=}), then
the collection.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{total }\OperatorTok{=} \FloatTok{0}

\ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in} \FloatTok{1}\OperatorTok{:}\FloatTok{10}
\NormalTok{    total }\OperatorTok{+=}\NormalTok{ n}
\ControlFlowTok{end}

\NormalTok{total}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
55
\end{verbatim}

This can be thought of as a special case of the \texttt{while} loop,
indeed in many cases, we can write the same thing with \texttt{while}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{total }\OperatorTok{=} \FloatTok{0}

\NormalTok{n }\OperatorTok{=} \FloatTok{1}
\ControlFlowTok{while}\NormalTok{ n }\OperatorTok{≤} \FloatTok{10}
\NormalTok{    total }\OperatorTok{+=}\NormalTok{ n}
\NormalTok{    n }\OperatorTok{+=} \FloatTok{1}
\ControlFlowTok{end}

\NormalTok{total}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
55
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-warning-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Warning}, colframe=quarto-callout-warning-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

The \texttt{for} loop introduces a problem we haven't had with any of
the blocks introduced so far: it also defines a variable at the same
time, namely \texttt{n} in the above. This variable is \emph{local} to
the loop, meaning that it doesn't exist outside of the loop. There are
some further intricacies with \texttt{for} and \texttt{while} loops and
the variables that can and can't be defined in them, which we'll discuss
more in Chapter~\ref{sec-customstructures}.

\end{tcolorbox}

\hypertarget{recursion}{%
\section{Recursion}\label{recursion}}

There's another way to create a loop in Julia, which is
\emph{recursion}. For this, we need to be able to write a custom
function, as we learn in Chapter~\ref{sec-customstructures}.

A recursive function is one that, as part of calculating its answer,
calls itself with different inputs (if you call it with the same inputs,
you'll get an infinite loop!), with a conditional used to stop the
recursion eventually at some base value. On the surface, this might seem
useless, or at best no better than \texttt{while} and \texttt{for} that
we've seen before, but let's use it for one of its most classic uses:
the Fibonacci sequence.

The Fibonacci sequence is defined as follows: \[
F_0 = 0, \qquad F_1 = 1, \qquad F_n = F_{n-1} + F_{n-2} \quad \text{for } n \geqslant 2
\]

and goes: \[
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987
\]

We can encapsulate this mathematical definition in code as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{fibonacci}\NormalTok{(n)}
\NormalTok{    n }\OperatorTok{==} \FloatTok{0} \OperatorTok{\&\&} \ControlFlowTok{return} \FloatTok{0}
\NormalTok{    n }\OperatorTok{==} \FloatTok{1} \OperatorTok{\&\&} \ControlFlowTok{return} \FloatTok{1}
    \ControlFlowTok{return} \FunctionTok{fibonacci}\NormalTok{(n}\OperatorTok{{-}}\FloatTok{1}\NormalTok{) }\OperatorTok{+} \FunctionTok{fibonacci}\NormalTok{(n}\OperatorTok{{-}}\FloatTok{2}\NormalTok{)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
fibonacci (generic function with 1 method)
\end{verbatim}

Indeed, this will work:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{fibonacci}\NormalTok{(}\FloatTok{16}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
987
\end{verbatim}

However, you might notice that it's quite inefficient. Every time the
function recurses, the function is called twice, so the number of
function calls in total is increasing exponentially in the input.
Depending on the computer that is running it, it will be able to
comfortably calculate up to about the 40th Fibonacci number in under a
second, but past that it gets debilitatingly slow very quickly. This is
a common issue with recursion, where the program can very easily get out
of control. Luckily, we can fix this problem rather easily, by simply
computing two numbers at a time:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Calculates Fₙ₊₁ and Fₙ}
\KeywordTok{function} \FunctionTok{fibonaccipair}\NormalTok{(n)}
\NormalTok{    n }\OperatorTok{==} \FloatTok{0} \OperatorTok{\&\&} \ControlFlowTok{return} \FloatTok{1}\NormalTok{, }\FloatTok{0}
\NormalTok{    Fₙ, Fₙ₋₁ }\OperatorTok{=} \FunctionTok{fibonaccipair}\NormalTok{(n}\OperatorTok{{-}}\FloatTok{1}\NormalTok{)}
    \ControlFlowTok{return}\NormalTok{ Fₙ }\OperatorTok{+}\NormalTok{ Fₙ₋₁, Fₙ}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
fibonaccipair (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{fastfibonacci}\NormalTok{(n)}
\NormalTok{    n }\OperatorTok{==} \FloatTok{0} \OperatorTok{\&\&} \ControlFlowTok{return} \FloatTok{0}
\NormalTok{    Fₙ, Fₙ₋₁ }\OperatorTok{=} \FunctionTok{fibonaccipair}\NormalTok{(n}\OperatorTok{{-}}\FloatTok{1}\NormalTok{)}
    \ControlFlowTok{return}\NormalTok{ Fₙ}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
fastfibonacci (generic function with 1 method)
\end{verbatim}

This recursive function can quickly compute any Fibonacci number up to
\(F_{92}\), when the limitations of Julia's \texttt{Int64} number format
kick in. \texttt{while} and \texttt{for} loops could achieve the same
thing, but in this case, recursion is a very natural tool for the job.

\hypertarget{stopping-loops}{%
\subsection{Stopping loops}\label{stopping-loops}}

When loops are involved, the bane of any programmer is the infinite
loop, such as the condition of a \texttt{while} loop never becoming
\texttt{false}, or recursion where the base case is never triggered.
Although \texttt{for} loops don't have the issue of running infinitely,
as they iterate over a finite number of things, they can still take
longer than expected and need cutting short.

For \texttt{while} loops, the simplest thing to do is to add a failsafe,
where after a certain number of iterations, the loop stops anyway
(possibly with an error, see the later section on
\href{@sec-controlflow_exceptions}{Exceptions}). We can see this in the
example \texttt{while} loop from before; the \texttt{iterations}
variable starts at \texttt{0}, and increments by \texttt{1} each cycle,
with the loop automatically cutting off if it reaches \texttt{100}.

Additionally, a loop can be stopped while it's running by pressing
\texttt{Ctrl}-\texttt{C} / \texttt{Cmd}-\texttt{C} (in fact, this can
stop any code from running, not just a loop). This should be seen as a
last resort, as terminating a computation halfway through leaves no
guarantee that the values that variables take are at all meaningful, but
it is very useful if for whatever reason your program gets out of hand.

Recursive functions have their own exception built into Julia to stop
them when they get out of hand. This is called
\texttt{StackOverflowError}, which means that too many nested functions
have been called in one go. This limit is actually from your operating
system, not Julia, but is big enough that realistically the only way to
reach it is with out of control recursion (for instance, the
\texttt{fastfibonacci} function above can calculate up to \(F_{52204}\),
if incorrectly due to \texttt{Int64} limitations). Nonetheless, this
does provide a hard limit to recursion.

There might also be algorithmic reasons that we would want to cut a loop
short, such as if the calculation has finished early, and we don't want
to waste time continuing going, or potentially ruining the result. For
this purpose, we can use the keyword \texttt{break}, telling Julia to
stop repeating the current block and move on. As an example, the
following loop would otherwise get all the way up to \texttt{9} before
stopping, but instead it is broken at \texttt{5}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i }\OperatorTok{=} \FloatTok{1}
\ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}} \FloatTok{10}
    \FunctionTok{println}\NormalTok{(i)}
    \CommentTok{\# Using short{-}circuiting, "break" is evaluated only when i is 5}
\NormalTok{    i }\OperatorTok{==} \FloatTok{5} \OperatorTok{\&\&} \ControlFlowTok{break}
\NormalTok{    i }\OperatorTok{+=} \FloatTok{1}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
2
3
4
5
\end{verbatim}

Alternatively, we may simply want to stop what we're doing in the
current iteration, and move on to the next. This can be done by the
keyword \texttt{continue}, used in the same way that \texttt{break}
would be used:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\OperatorTok{=} \FloatTok{1}\OperatorTok{:}\FloatTok{3}
\NormalTok{    i }\OperatorTok{==} \FloatTok{2} \OperatorTok{\&\&} \ControlFlowTok{continue}
    \FunctionTok{println}\NormalTok{(i)}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
3
\end{verbatim}

\hypertarget{sec-controlflow_exceptions}{%
\section{Exceptions}\label{sec-controlflow_exceptions}}

We've already met some exceptions from erroneous code that we've written
(and if you're following along yourself by writing some of your own
examples, inevitably you'll have seen more). However, we may want to
introduce our own error messages, for diagnostic purposes within our own
programs.

The simplest way of doing this is the \texttt{error} function, which
takes a \texttt{String} as argument that will become an error message:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{error}\NormalTok{(}\StringTok{"an error has occurred."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: an error has occurred.
\end{verbatim}

There are also various \texttt{Exception} types, allowing special errors
to be constructed with more information, much of which are used in the
common errors that we see. The function \texttt{throw} serves to cause
the error to occur, stopping the program and giving the message.

\begin{Shaded}
\begin{Highlighting}[]
\ConstantTok{e} \OperatorTok{=} \FunctionTok{BoundsError}\NormalTok{(}\StringTok{"message"}\NormalTok{, }\FloatTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
BoundsError("message", 10)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{throw}\NormalTok{(}\ConstantTok{e}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: BoundsError: attempt to access 7-codeunit String at index [10]
\end{verbatim}

This is most useful when combined with conditionals, so we can detect if
an error has occurred, and raise an exception if needs be.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \OperatorTok{{-}}\FloatTok{1}
\NormalTok{x }\OperatorTok{\textgreater{}} \FloatTok{0} \OperatorTok{||} \FunctionTok{throw}\NormalTok{(}\FunctionTok{DomainError}\NormalTok{(x, }\StringTok{"x must be positive"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: DomainError with -1:
x must be positive
\end{verbatim}

\hypertarget{sec-customstructures}{%
\chapter{Creating custom structures}\label{sec-customstructures}}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-important-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Prerequisites}, colframe=quarto-callout-important-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Before reading this chapter, you are recommended to have read
Chapter~\ref{sec-fundamentals}. Also valuable will be
Chapter~\ref{sec-controlflow}, in particular for the discussion of
scope.

\end{tcolorbox}

In Chapter~\ref{sec-fundamentals}, we already met \emph{variables},
\emph{functions}, and \emph{types} at a basic level. We'll now look at
them in a little more detail, in particular focusing on creating our own
custom functions and types to morph Julia's behaviour to our needs.
We'll also endeavour to better understand variables, primarily their
\emph{scope}.

\hypertarget{symbol}{%
\section{\texorpdfstring{\texttt{Symbol}}{Symbol}}\label{symbol}}

First, however, let's meet an important new type: \texttt{Symbol}. On
the surface, the \texttt{Symbol} type is much like a \texttt{String},
indeed to write a \texttt{Symbol}, we start with a colon \texttt{:}, and
then write our word:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OperatorTok{=} \OperatorTok{:}\NormalTok{symbol}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
:symbol
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(s)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Symbol
\end{verbatim}

\texttt{Symbol}s work with the same sort of names that work as variable
names. If we try to create \texttt{Symbol}s with invalid names, such as
using numeric or \texttt{String} literals, we can see that Julia
interprets it just as the literal we've written:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{:}\FloatTok{6}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\OperatorTok{:}\FloatTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Int64
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{:}\StringTok{"six"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"six"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\OperatorTok{:}\StringTok{"six"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
String
\end{verbatim}

This is because a \texttt{Symbol} represents what Julia reads when we
give it text. If we type \texttt{print}, Julia reads \texttt{:print},
and recognises this \texttt{Symbol} as corresponding to a function. If
we type \texttt{1.4}, Julia reads this as it is, as the \texttt{Float64}
literal \texttt{1.4}, and deals with it as such.

\texttt{Symbol}s are not only used as an internal technicality in Julia
though. They are often used at a human level in Julia as names, in place
of \texttt{String}s, for instance the \texttt{Colors} package recognises
colour names such as \texttt{:red}, \texttt{:blue}, \texttt{:violet} in
\texttt{Symbol} form. This is a sensible because \texttt{Symbol}s are
words, whereas \texttt{String}s are sequences of characters, and when
referring to items by their names, we don't care about the individual
characters, we care about the name as a whole.

\hypertarget{custom-functions}{%
\section{Custom functions}\label{custom-functions}}

\hypertarget{defining-a-new-function}{%
\subsection{Defining a new function}\label{defining-a-new-function}}

Functions allow preset algorithms to written and referred to by a name,
much like variables allow for a value to be referred to by name instead
of remembering it. Julia has plenty of inbuilt functions, for all sorts
of task, and the ecosystem of packages (see Chapter~\ref{sec-packages})
only adds to that. However, these functions are written to serve as the
ingredients, not the end product, and most of the time they aren't
specialised enough to do what we want to do in one simple call. Instead,
we need to build up these ingredients into a new function of our own.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, colframe=quarto-callout-note-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Technically, what we're writing here are not functions, but
\emph{methods} for functions. Functions are the object with the name,
and are what are accessed when we call them, but each function can have
many methods which dictate the code that will actually run. Methods
don't have names as such, instead they're distinguished by different
patterns of inputs, and choosing which method to run when is the point
of \emph{multiple dispatch}, which we'll meet in
Chapter~\ref{sec-multipledispatch}. For instance, \texttt{range} is a
function, with four methods:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{methods}\NormalTok{(range)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# 6 methods for generic function "range" from Base:
 [1] range(; start, stop, length, step)
     @ range.jl:147
 [2] range(start::T; stop, length) where T<:ColorTypes.Colorant
     @ Colors C:\Users\James\.julia\packages\Colors\mIuXl\src\utilities.jl:230
 [3] range(start::T, stop::T; kwargs...) where T<:ColorTypes.Colorant
     @ Colors C:\Users\James\.julia\packages\Colors\mIuXl\src\utilities.jl:235
 [4] range(start; stop, length, step)
     @ range.jl:142
 [5] range(start, stop; length, step)
     @ range.jl:144
 [6] range(start, stop, length::Integer)
     @ range.jl:145
\end{verbatim}

For now, we'll use the words \emph{function} and \emph{method} mostly
interchangeably.

\end{tcolorbox}

First, we need to give the function a name (the same as we would a
variable), as well as give variable names to the inputs to the function
that we expect. To tell Julia that we want a function, we use the
keyword \texttt{function}, followed by the name that we want to give it.
Then, we list out the number of inputs (also called \emph{arguments})
that we want, giving each of them a name as well to be referred to
later. These need to be separated by commas, just as multiple inputs to
a function do when we call it.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{spherevolume}\NormalTok{(radius)}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Convention}, colframe=quarto-callout-tip-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

In Julia, function names are usually written in lowercase with no
spaces. They should also be named to not conflict with existing
functions, so as not to overwrite them. We can, however, add onto
existing functions, as we'll see in Chapter~\ref{sec-multipledispatch}.

\end{tcolorbox}

Next comes the code, doing whatever calculations we need it to do on the
inputs. This works much the same as code anywhere else, so we won't
really focus on it here. Indeed, for some later examples, you may not
recognise all the syntax being used, but you can feel free to ignore it
if so. All that's important is that something fills in this gap.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    volume }\OperatorTok{=} \FloatTok{4}\OperatorTok{/}\FloatTok{3} \OperatorTok{*} \ConstantTok{π} \OperatorTok{*}\NormalTok{ radius}\OperatorTok{\^{}}\FloatTok{3}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Convention}, colframe=quarto-callout-tip-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

This code is indented once compared to the level of the
\texttt{function} keyword, for readability purposes to clearly show
which code belongs to the function.

\end{tcolorbox}

Finally, we want to return our answer, which will be what we get back
when the function is run. Using the \texttt{return} keyword before a
value tells the function to return that as the answer (this is
particularly useful when combined with conditionals from
Chapter~\ref{sec-controlflow}), but if \texttt{return} is never
specified, the function will default to returning the last value it
calculated. We then finish off the block with \texttt{end}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{end} \CommentTok{\# In this case, the volume is the last thing calculated, so we don\textquotesingle{}t need \textasciigrave{}return\textasciigrave{}}
\end{Highlighting}
\end{Shaded}

Putting this all together, we have a function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{spherevolume}\NormalTok{(radius)}
\NormalTok{    volume }\OperatorTok{=} \FloatTok{4}\OperatorTok{/}\FloatTok{3} \OperatorTok{*} \ConstantTok{π} \OperatorTok{*}\NormalTok{ radius}\OperatorTok{\^{}}\FloatTok{3}
    \ControlFlowTok{return}\NormalTok{ volume }\CommentTok{\# Using \textasciigrave{}return\textasciigrave{} here is redundant, but for clarity we show it here}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
spherevolume (generic function with 1 method)
\end{verbatim}

We can use this just as we would any other function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{spherevolume}\NormalTok{(}\FloatTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4.1887902047863905
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{spherevolume}\NormalTok{(}\FloatTok{0.781592641796772}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1.9999999999999996
\end{verbatim}

Alternatively, functions can be written using more algebraic syntax. We
do away with the \texttt{function}-\texttt{end} block, instead writing
in one line how to calculate the output from the inputs

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cubevolume}\NormalTok{(length) }\OperatorTok{=}\NormalTok{ length}\OperatorTok{\^{}}\FloatTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
cubevolume (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cubevolume}\NormalTok{(}\FloatTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cubevolume}\NormalTok{(}\FloatTok{1.2599210498948732}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2.0
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Convention}, colframe=quarto-callout-tip-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

For longer functions, combining this syntax with a
\texttt{begin}-\texttt{end} block can give the same effect as using
\texttt{function}-\texttt{end}. However, the latter is preferable in
most cases; the algebraic-style syntax is intended as convenient
shorthand for the normal \texttt{function}-\texttt{end} syntax for quick
functions.

\end{tcolorbox}

It's possible to make functions that return multiple arguments, simply
by following \texttt{return} with a list of comma-separated values. For
example, we can mimic the inbuilt function \texttt{minmax}, which given
two inputs, returns the smallest followed by the largest:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{minmaxagain}\NormalTok{(x, y)}
    \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}}\NormalTok{ y}
        \ControlFlowTok{return}\NormalTok{ y, x}
    \ControlFlowTok{else}
        \ControlFlowTok{return}\NormalTok{ x, y}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
minmaxagain (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{minmaxagain}\NormalTok{(}\FloatTok{4}\NormalTok{,}\FloatTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(4, 5)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{minmaxagain}\NormalTok{(}\FloatTok{5}\NormalTok{,}\FloatTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(4, 5)
\end{verbatim}

If we provide one variable as an output, it will take the value of the
\texttt{Tuple} containing all outputs:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \FunctionTok{minmaxagain}\NormalTok{(}\FloatTok{5}\NormalTok{,}\FloatTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(4, 5)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(4, 5)
\end{verbatim}

However, if we provide two, the first will get the first value, and the
second the second:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y, z }\OperatorTok{=} \FunctionTok{minmaxagain}\NormalTok{(}\FloatTok{5}\NormalTok{,}\FloatTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(4, 5)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5
\end{verbatim}

Using certain symbols as function names (particularly those in the
\emph{Symbol, Math} category in Unicode) allows them to be used
automatically as infix operations, as we are used to with the likes of
\texttt{+}, \texttt{-}, \texttt{*}, etc.:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{±}\NormalTok{(x, y) }\OperatorTok{=}\NormalTok{ (x }\OperatorTok{+}\NormalTok{ y, x }\OperatorTok{{-}}\NormalTok{ y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
± (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{0.8} \OperatorTok{±} \FloatTok{0.03}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(0.8300000000000001, 0.77)
\end{verbatim}

\hypertarget{prescribing-the-inputs}{%
\subsection{Prescribing the inputs}\label{prescribing-the-inputs}}

Not all functions should accept all inputs, in fact, there are very few
that should! What's more, we may want the function to do different
things depending on the inputs, via multiple dispatch. To remedy this at
least partially, Julia provides type declarations, allowing us to
prescribe what types are allowed for specific inputs.

To declare the type of a specific argument, we follow the variable name
we've given it by two colons \texttt{::} and the type name:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{spherevolume}\NormalTok{(radius}\OperatorTok{::}\DataTypeTok{Float64}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Often, there may be many types which would work as the input. If there
is a natural supertype that encompasses all of these, we can use that,
even if it is an abstract type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{spherevolume}\NormalTok{(radius}\OperatorTok{::}\DataTypeTok{Real}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

More unusual possibilites can be realised with the \texttt{Union} type,
which takes other types as parameters, and acts as a supertype for all
of them:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Can\textquotesingle{}t use this for \textasciigrave{}Bool\textasciigrave{}, as \textasciigrave{}true + one(true)\textasciigrave{} gives \textasciigrave{}2\textasciigrave{}, which isn\textquotesingle{}t a \textasciigrave{}Bool\textasciigrave{}}
\KeywordTok{function} \FunctionTok{nextinteger}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Union\{Signed,Unsigned\}}\NormalTok{)}
\NormalTok{    x }\OperatorTok{+} \FunctionTok{one}\NormalTok{(x)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
nextinteger (generic function with 1 method)
\end{verbatim}

Here, the use of \texttt{Union} is justified, since we do the same thing
for \texttt{Signed} and \texttt{Unsigned} inputs, and we can't use
\texttt{Integer} because we want to exclude \texttt{Bool}. However, if
the algorithm of your function changes significantly depending on the
exact types it gets as inputs, then multiple methods for the function
with each of those cases covered should be written. To see this, and
more complicated type declarations, see
Chapter~\ref{sec-multipledispatch}.

What we can't do in this way is restrict to only certain values within a
type. For example, we can't declare that the \texttt{radius} in
\texttt{spherevolume} needs to be positive, because multiple dispatch
sees only types, not values. This will require a check in the body of
the function, for example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{radius }\OperatorTok{\textless{}} \FloatTok{0} \OperatorTok{\&\&} \FunctionTok{throw}\NormalTok{(}\FunctionTok{DomainError}\NormalTok{(radius, }\StringTok{"sphere must have positive radius."}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Another way we may wish to prescribe the inputs is by giving them
default values, making specifying them optional. The following function
cuts a \texttt{String} \texttt{s} after the \texttt{n}th character, if
it is long enough. Here, it's combined with type specification, but it
needen't be.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{cutstring}\NormalTok{(s}\OperatorTok{::}\DataTypeTok{String}\NormalTok{, n}\OperatorTok{::}\DataTypeTok{Int64 }\OperatorTok{=} \FloatTok{1}\NormalTok{)}
    \FunctionTok{length}\NormalTok{(s) }\OperatorTok{\textless{}}\NormalTok{ n ? s }\OperatorTok{:}\NormalTok{ s[}\FloatTok{1}\OperatorTok{:}\NormalTok{n]   }
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
cutstring (generic function with 2 methods)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cutstring}\NormalTok{(}\StringTok{"hydrogen"}\NormalTok{, }\FloatTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"hydrog"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cutstring}\NormalTok{(}\StringTok{"boron"}\NormalTok{, }\FloatTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"boron"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cutstring}\NormalTok{(}\StringTok{"gold"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"g"
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, colframe=quarto-callout-note-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

When we defined \texttt{cutstring}, we can see that it defined a
function with 2 methods, instead of 1 method like the other functions
we've defined. This is because, in the background, it's defined a second
method:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cutstring}\NormalTok{(s}\OperatorTok{::}\DataTypeTok{String}\NormalTok{) }\OperatorTok{=} \FunctionTok{cutstring}\NormalTok{(s, }\FloatTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

with only one input, corresponding to what happens if you don't give
\texttt{n} a value.

\end{tcolorbox}

Functions with lots of inputs can be clunky to call, as you need to
remember exactly what order the inputs need to go in. Instead, we can
write functions with keyword arguments, which differ from normal
arguments in that you specify them by name, not by order.

The volume of a cone of radius \(r\) and height \(h\) is given by
\(\frac{1}{3} \pi r^2 h\). However, writing a function for this, it's
not clear what order \texttt{radius} and \texttt{height} should go. We
could make a choice, but instead, let's make them keyword arguments, so
that someone using the function can't get them the wrong way around.
Arguments are usually separated by commas, but after a semi-colon, all
arguments become keyword arguments:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{conevolume}\NormalTok{(; radius, height) }\OperatorTok{=} \FloatTok{1}\OperatorTok{/}\FloatTok{3} \OperatorTok{*} \ConstantTok{π} \OperatorTok{*}\NormalTok{ radius}\OperatorTok{\^{}}\FloatTok{2} \OperatorTok{*}\NormalTok{ height}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
conevolume (generic function with 1 method)
\end{verbatim}

If we try to call the function as normal, we'll get an error:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{conevolume}\NormalTok{(}\FloatTok{1}\NormalTok{, }\FloatTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: MethodError: no method matching conevolume(::Int64, ::Int64)
\end{verbatim}

Instead, we need to specify which argument is which by naming them:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{conevolume}\NormalTok{(radius }\OperatorTok{=} \FloatTok{1}\NormalTok{, height }\OperatorTok{=} \FloatTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1.0471975511965976
\end{verbatim}

Since they have names, the order is now irrelevant:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{conevolume}\NormalTok{(height }\OperatorTok{=} \FloatTok{1}\NormalTok{, radius }\OperatorTok{=} \FloatTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1.0471975511965976
\end{verbatim}

Just as with normal arguments, keyword arguments can have types declared
or default values given. Function can also have a combination of normal
arguments and keyword arguments:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{friedeggs}\NormalTok{(eggs; people }\OperatorTok{=} \FloatTok{2}\NormalTok{)}
    \FunctionTok{println}\NormalTok{(}\StringTok{"This recipe serves }\SpecialCharTok{$}\NormalTok{(people)}\StringTok{ people."}\NormalTok{)}
    \FunctionTok{println}\NormalTok{(}\StringTok{"You will need }\SpecialCharTok{$}\NormalTok{(eggs }\OperatorTok{*}\NormalTok{ people)}\StringTok{ eggs."}\NormalTok{)}
    \FunctionTok{println}\NormalTok{(}\StringTok{"To make fried eggs, simply crack the eggs into a pan and wait."}\NormalTok{)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
friedeggs (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{friedeggs}\NormalTok{(}\FloatTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
This recipe serves 2 people.
You will need 10 eggs.
To make fried eggs, simply crack the eggs into a pan and wait.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{friedeggs}\NormalTok{(}\FloatTok{2}\NormalTok{; people }\OperatorTok{=} \FloatTok{12}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
This recipe serves 12 people.
You will need 24 eggs.
To make fried eggs, simply crack the eggs into a pan and wait.
\end{verbatim}

\hypertarget{anonymous-functions}{%
\subsection{Anonymous functions}\label{anonymous-functions}}

We've already seen two different syntaxes for defining functions, but in
fact, there's a third:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f }\OperatorTok{=}\NormalTok{ x }\OperatorTok{{-}\textgreater{}}\NormalTok{ x}\OperatorTok{\^{}}\FloatTok{2} \OperatorTok{{-}} \FloatTok{3}\NormalTok{x }\OperatorTok{+} \FloatTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#15 (generic function with 1 method)
\end{verbatim}

This function behaves just as others do:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{f}\NormalTok{(}\FloatTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{f}\NormalTok{(}\FloatTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
72
\end{verbatim}

However, it's a little different. This is no longer a function called
\texttt{f}, it's a variable called \texttt{f} whose value is a function.
Using the \texttt{methods} functon to list the methods, we get:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{methods}\NormalTok{(f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# 1 method for anonymous function "#15":
 [1] (::var"#15#16")(x)
     @ In[37]:1
\end{verbatim}

As we can see here, \texttt{f} is what is called an anonymous function,
which is a fitting description as they don't have a name like normal
functions do. Anonymous functions don't participate in multiple
dispatch, and so can only have one method, but can be used more easily
as a variable. Their main use is for functions that themselves take
functions as arguments, such as \texttt{minimum}, which finds the
minimum value that a function takes on a given set of inputs:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{minimum}\NormalTok{(f, }\FloatTok{0}\OperatorTok{:}\FloatTok{0.01}\OperatorTok{:}\FloatTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
-0.25
\end{verbatim}

Indeed, we don't even need to give an anonymous function a variable
name, and we can enter it as a literal:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{minimum}\NormalTok{(x }\OperatorTok{{-}\textgreater{}}\NormalTok{ x}\OperatorTok{\^{}}\FloatTok{2} \OperatorTok{+} \FloatTok{4}\NormalTok{x }\OperatorTok{{-}} \FloatTok{3}\NormalTok{, }\OperatorTok{{-}}\FloatTok{3}\OperatorTok{:}\FloatTok{0.01}\OperatorTok{:{-}}\FloatTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
-7.0
\end{verbatim}

\hypertarget{piping-and-composing-functions}{%
\subsection{Piping and composing
functions}\label{piping-and-composing-functions}}

A common occurrence in programming with functions is the need to apply
several functions one after the other to the same value. The problem is,
this can lead to a mess of parentheses. Let's say we have a variable
called \texttt{capital}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{capital }\OperatorTok{=} \StringTok{"Antananarivo"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"Antananarivo"
\end{verbatim}

We want to do two calculations on it. First, we want to count the number
of unique letters (ignoring upper and lower case), which we can do as
follows:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(}\FunctionTok{unique!}\NormalTok{(}\FunctionTok{sort!}\NormalTok{(}\FunctionTok{collect}\NormalTok{(}\FunctionTok{lowercase}\NormalTok{(capital)))))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
7
\end{verbatim}

Also, we want to find if the last appearance of the letter
\texttt{\textquotesingle{}a\textquotesingle{}} is an even number of
letters from the end:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{iseven}\NormalTok{(}\FunctionTok{findfirst}\NormalTok{(}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\FunctionTok{reverse}\NormalTok{(}\FunctionTok{lowercase}\NormalTok{(capital))))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
false
\end{verbatim}

Both of these are a bit of an eyesore. Julia provides two ways of
helping with this, each with their own benefits. The first is
\emph{piping}, which uses the \texttt{\textbar{}\textgreater{}} operator
to successively apply functions to the output of the previous step:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{capital }\OperatorTok{|\textgreater{}}\NormalTok{ lowercase }\OperatorTok{|\textgreater{}}\NormalTok{ collect }\OperatorTok{|\textgreater{}}\NormalTok{ sort! }\OperatorTok{|\textgreater{}}\NormalTok{ unique! }\OperatorTok{|\textgreater{}}\NormalTok{ length}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
7
\end{verbatim}

This can also include anonymous functions as arguments, which can be
useful when we need to add an input to one of the functions along the
way:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{capital }\OperatorTok{|\textgreater{}}\NormalTok{ lowercase }\OperatorTok{|\textgreater{}}\NormalTok{ reverse }\OperatorTok{|\textgreater{}}\NormalTok{ (x }\OperatorTok{{-}\textgreater{}} \FunctionTok{findfirst}\NormalTok{(}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, x)) }\OperatorTok{|\textgreater{}}\NormalTok{ iseven}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
false
\end{verbatim}

This is much cleaner, as it better separates the many function
applications into a readable format. The second option we have is
\emph{composition}, which is done with the \texttt{∘} operator (typed by
tab-completing \texttt{\textbackslash{}circ}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(length }\OperatorTok{∘}\NormalTok{ unique! }\OperatorTok{∘}\NormalTok{ sort! }\OperatorTok{∘}\NormalTok{ collect }\OperatorTok{∘}\NormalTok{ lowercase)(capital)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
7
\end{verbatim}

Under the hood, \texttt{∘} creates a special type of function called a
\texttt{ComposedFunction}, which works just like a normal function, but
calling each of its component parts one at a time in the prescribed
order. This means we can give it a variable name, and use it as we would
a normal function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{contrivedfunction }\OperatorTok{=}\NormalTok{ (iseven }\OperatorTok{∘}\NormalTok{ (x }\OperatorTok{{-}\textgreater{}} \FunctionTok{findfirst}\NormalTok{(}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, x)) }\OperatorTok{∘}\NormalTok{ reverse }\OperatorTok{∘}\NormalTok{ lowercase)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
iseven ∘ var"#21#22"() ∘ reverse ∘ lowercase
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(contrivedfunction)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ComposedFunction{ComposedFunction{ComposedFunction{typeof(iseven), var"#21#22"}, typeof(reverse)}, typeof(lowercase)}
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{contrivedfunction}\NormalTok{(capital)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
false
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, colframe=quarto-callout-note-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

While we aren't thinking of them as such here, all functions are
actually just a special type of variable. Specifically, that special
type is a subtype of \texttt{Function}, named
\texttt{typeof({[}function-name{]})}, with the property that preceding a
\texttt{Tuple} with a function's name starts multiple dispatch on the
methods stored under that name. They are also \texttt{const} values (see
later), so cannot be redefined as any other type.

\end{tcolorbox}

\hypertarget{custom-types}{%
\section{Custom types}\label{custom-types}}

\hypertarget{types-of-types}{%
\subsection{Types of types}\label{types-of-types}}

Types are all important in letting Julia know how to deal with the data
we give it. As we've seen above, they are invaluable in determining what
values a method of a function can accept, and
Chapter~\ref{sec-numerictypes} gives an idea of why we might choose a
particular format to store our data in (e.g.~\texttt{Float64} for speed,
\texttt{Rational\{BigInt\}} for accuracy) Much as we can add to Julia's
many functions with our own, we can do the same with types. First
though, let's cover the different flavours of types which Julia affords
us.

The most common is the \emph{composite type}. Such a type has various
\emph{fields}, each with a given value. We'll see what this actually
means when we come to define one, but an example for now is
\texttt{ErrorException}, which is the type you get when using the
function \texttt{error}.

\begin{Shaded}
\begin{Highlighting}[]
\ConstantTok{e} \OperatorTok{=} \FunctionTok{ErrorException}\NormalTok{(}\StringTok{"an error"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ErrorException("an error")
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{throw}\NormalTok{(}\ConstantTok{e}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: an error
\end{verbatim}

It has a single field \texttt{msg} of type \texttt{AbstractString},
which stores the error message to be displayed.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{fieldnames}\NormalTok{(}\DataTypeTok{ErrorException}\NormalTok{) }\CommentTok{\# The function \textasciigrave{}fieldnames\textasciigrave{} lists the fields of a type}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(:msg,)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{ErrorException}\NormalTok{.types }\CommentTok{\# The property \textasciigrave{}types\textasciigrave{} of a type lists the types of the fields}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
svec(AbstractString)
\end{verbatim}

Related to the composite type is the \emph{parametric type}, which
behaves much the same, but it also requires one or more other types in
curly braces after its name to specify exactly what data it represents.
An example of this from Chapter~\ref{sec-numerictypes} is
\texttt{Rational}, which requires a type parameter to tell us what
format the numerator and denominator are in:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\FloatTok{4}\OperatorTok{//}\FloatTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Rational{Int64}
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\FunctionTok{BigInt}\NormalTok{(}\FloatTok{4}\NormalTok{)}\OperatorTok{//}\FunctionTok{BigInt}\NormalTok{(}\FloatTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Rational{BigInt}
\end{verbatim}

A \emph{mutable type} can be either composite or parametric, but it has
the property that its fields can be edited after it is instantiated. The
data corresponding to a variable with a mutable type is stored not as
values, but as \emph{pointers} which serve as addresses to where the
values are stored, and therefore these values can be changed without
changing any of the data defining the variable. The prototypical example
of a mutable type is \texttt{Array} (which is also parametric), as
described in Chapter~\ref{sec-arrays}.

If a composite type or a parametric type has no fields, and is
immutable, then there is no way to distinguish any one instance of that
type from any other. This makes it a \emph{singleton type}, examples of
which include function types such as \texttt{typeof(sin)}, and
\texttt{Nothing} which represents the absence of a value.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\FunctionTok{Nothing}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Nothing
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{fieldnames}\NormalTok{(}\DataTypeTok{Nothing}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
()
\end{verbatim}

A \emph{primitive type} is one where the data is stored primitively,
meaning it is just zeroes and ones in memory (of course, everything is
just zeroes and ones eventually, but most types have fields as an
intermediate step). For instance, \texttt{Int64} is a primitive type,
where any data in this format is 64 consecutive bits of memory that
exactly correspond to the value we mean by it.

FInally, an \emph{abstract type} cannot take a value, but instead serves
as a label collecting together many related types, allowing them to be
referred to as a collective (such as for the purposes of multiple
dispatch). Again, we return to Chapter~\ref{sec-numerictypes} and
numeric types for an example of this, with \texttt{Number} encompassing
all possible numeric types, \texttt{Real} excluding complex numbers,
\texttt{Integer} excluding fractional numbers, and so on.

Some inbuilt types don't fit nicely into these categories, particularly
those more fundamental to the inner workings of Julia. For example,
\texttt{String} isn't primitive, but still doesn't have any fields; it's
mutable, but you can't change its characters. However, any types that we
define will follow the usual rules.

\hypertarget{defining-a-new-type}{%
\subsection{Defining a new type}\label{defining-a-new-type}}

To define a new composite type, we use the keyword \texttt{Struct},
followed by the name we want to give the type. Then, on

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Animal}
\NormalTok{    name}\OperatorTok{::}\DataTypeTok{String}
\NormalTok{    symbol}\OperatorTok{::}\DataTypeTok{Char}
\NormalTok{    legs}\OperatorTok{::}\DataTypeTok{Int64}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Convention}, colframe=quarto-callout-tip-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Types are named in upper camel-case, meaning every word is capitalised,
with no spaces separating words. For examples, consider types that we
have already met, like \texttt{String}, \texttt{BigInt}, and
\texttt{Function}.

\end{tcolorbox}

We can instantiate a variable of this type by using the name of the type
like a function, with the arguments being the values we want to give to
the fields in the same order that we defined them:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{elephant }\OperatorTok{=} \FunctionTok{Animal}\NormalTok{(}\StringTok{"Elephant"}\NormalTok{, }\CharTok{\textquotesingle{}🐘\textquotesingle{}}\NormalTok{, }\FloatTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Animal("Elephant", '🐘', 4)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{flamingo }\OperatorTok{=} \FunctionTok{Animal}\NormalTok{(}\StringTok{"Flamingo"}\NormalTok{, }\CharTok{\textquotesingle{}🦩\textquotesingle{}}\NormalTok{, }\FloatTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Animal("Flamingo", '🦩', 2)
\end{verbatim}

We use dot syntax to query the value of one of the fields, following the
variable with a \texttt{.}, and then the name of the field we want to
know:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{elephant.symbol}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
'🐘': Unicode U+1F418 (category So: Symbol, other)
\end{verbatim}

If these were mutable types, we could use the same syntax followed by an
\texttt{=} to change their values. However, \texttt{Animal} is
immutable, so we get an error:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{flamingo.legs }\OperatorTok{=} \FloatTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: setfield!: immutable struct of type Animal cannot be changed
\end{verbatim}

It is also possible to declare where our new type belongs in the type
graph, by giving it an abstract type as a parent node. This can be done
by following the type name with \texttt{\textless{}:}, and then the
abstract type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Prime }\OperatorTok{\textless{}:}\DataTypeTok{ Integer}
\NormalTok{    p}\OperatorTok{::}\DataTypeTok{BigInt}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{=} \FunctionTok{Prime}\NormalTok{(}\FunctionTok{BigInt}\NormalTok{(}\FloatTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Prime(5)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p isa }\DataTypeTok{Integer}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

If no parent is specified, it defaults to \texttt{Any}, which is the
abstract type at the top of the tree.

We can also define our own parametric types, by following our type name
with curly braces, inside which we can give variable names to our list
of parameters.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Doublet\{T\}}
\NormalTok{    first}\OperatorTok{::}\DataTypeTok{T}
\NormalTok{    second}\OperatorTok{::}\DataTypeTok{T}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Doublet}\DataTypeTok{\{Int64\}}\NormalTok{(}\FloatTok{10}\NormalTok{, }\FloatTok{20}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Doublet{Int64}(10, 20)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Doublet}\DataTypeTok{\{Symbol\}}\NormalTok{(}\OperatorTok{:}\NormalTok{ten, }\OperatorTok{:}\NormalTok{twenty)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Doublet{Symbol}(:ten, :twenty)
\end{verbatim}

We can restrict these parameters if needs be, for example if we needed
the parameter \texttt{T} to be numeric, we could have written:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Doublet\{T }\OperatorTok{\textless{}:}\DataTypeTok{ Number}\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Parameters are usually other types, but don't need to be, for example
\texttt{Array} (see Chapter~\ref{sec-arrays}) has two parameters
\texttt{T} and \texttt{N}, which define the type of the elements
\texttt{T}, and the number of dimensions \texttt{N}. We'll see an
example of this below when considering inner constructors, which are
required to deal with parametric types with values as parameters.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, colframe=quarto-callout-note-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

The other varieties of types can also be defined:

\begin{itemize}
\item
  If you want to create an abstract type to add to the type graph,
  replace \texttt{struct} with \texttt{abstract\ type} (note that you
  can't specify any fields, since an abstract type can never take a
  value)
\item
  If you want to make your type mutable (see Chapter~\ref{sec-arrays}),
  replace \texttt{struct} with \texttt{mutable\ struct}
\item
  If you (for some reason) want to create your own primitive type,
  replace \texttt{struct} with \texttt{primitive\ type}, and add the
  number of bits you want your type to take up in place of fields.
  However, be warned that most problems are made more complicated by
  using primitive types instead of composite types
\end{itemize}

\end{tcolorbox}

\hypertarget{inner-constructors}{%
\subsection{Inner constructors}\label{inner-constructors}}

For some composite and parametric types we create, it may suffice to
simply specify the fields and their types. However, we may want to have
more flexibility, or further restrictions, in defining instances of our
new type. To do this, we'll want to make use of \emph{constructors}.

Constructors looks very much like a method of a function, and can be
thought of as such, behaving the same way when to calling it with a
\texttt{Tuple} of inputs, and participating in multiple dispatch. What's
special about them, however, is that the function's name is the type
which they construct, for instance calling a constructor for the type
\texttt{Rational\{Int64\}} might look like
\texttt{Rational\{Int64\}(4,\ 5)}. In fact, we've already used
constructors unwittingly in Chapter~\ref{sec-numerictypes}, to convert
between the various numeric types in Julia, and in
Chapter~\ref{sec-controlflow}, to create exceptions.

The first type of constructor we'll look at is the \emph{inner
constructor}. These are defined inside the \texttt{struct} block (hence
\emph{inner}), after the fields are listed, and their primary purpose is
to impose further restrictions on the fields than simply their types. To
create an inner constructor, we use the same syntax as we did when
creating a function (either the \texttt{function}-\texttt{end} block or
the algebraic \texttt{f(x)\ =} syntax will work, but not the anonymous
function syntax as we don't want to create an anonymous function).

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Convention}, colframe=quarto-callout-tip-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

The arguments of this function should be the fields, in the same order
as listed before, with the same names and type declarations. While this
function will be called just like any other, with the variable names
strictly local to the function, it's pointlessly more difficult to read
if the field names are changed or reordered.

\end{tcolorbox}

The body of the function will consist of whatever checks we need to do,
with either the fields corrected if possible, or \texttt{Exception}s
thrown when the values are irretrievably wrong. However, since there
doesn't exist a function to create a new instance of our type to return
(that's what we're writing with the inner constructor), we need to use
the special function \texttt{new}. The \texttt{new} function is
exclusive to inner constructors, and simply instantiates a variable of
the type in question with fields as listed in the arguments. For
example, a type with two fields that we wanted to have values \texttt{2}
and \texttt{"two"} would be created by \texttt{new(2,\ "two")}. Mostly,
this will be the value you want the function to return, so we can finish
the function with a call to \texttt{new}, creating and returning our new
object back to us.

For a familiar example, let's create a type called \texttt{Password}, in
which we'll store a single field of type \texttt{String} to represent
the password. This will be a parametric type, with a single parameter
\texttt{N} which will be an \texttt{Integer}. Using values as parameters
is another task for inner constructors, as we can't do it with type
declarations. We also want to impose some restrictions on the password:

\begin{itemize}
\item
  It must contain at least \texttt{N} characters in total (so if
  \texttt{N} is zero or negative, then any length will be allowed)
\item
  It must contain at least two letters and two numbers
\item
  It must contain at least one character than isn't a letter or a number
\end{itemize}

The tools from Chapter~\ref{sec-controlflow} suffice to make these
checks, so we'll use them to build our inner constructor:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Password\{N\}}
\NormalTok{    word}\OperatorTok{::}\DataTypeTok{String}

    \KeywordTok{function} \FunctionTok{Password}\DataTypeTok{\{N\}}\NormalTok{(word}\OperatorTok{::}\DataTypeTok{String}\NormalTok{) }\KeywordTok{where}\NormalTok{ N}
        \CommentTok{\# Checks that N is an integer}
\NormalTok{        N isa }\DataTypeTok{Integer} \OperatorTok{||} \FunctionTok{throw}\NormalTok{(}\FunctionTok{TypeError}\NormalTok{(}\StringTok{"parameter for \textasciigrave{}Password\textasciigrave{} must be an \textasciigrave{}Integer\textasciigrave{}."}\NormalTok{))}

        \CommentTok{\# Checks length}
        \FunctionTok{length}\NormalTok{(word) }\OperatorTok{\textless{}}\NormalTok{ N }\OperatorTok{\&\&} \FunctionTok{throw}\NormalTok{(}\FunctionTok{ArgumentError}\NormalTok{(}\StringTok{"password must contain at least }\SpecialCharTok{$}\NormalTok{N}\StringTok{ characters."}\NormalTok{))}
        
        \CommentTok{\# Counts the number of each character type}
\NormalTok{        letters }\OperatorTok{=}\NormalTok{ numbers }\OperatorTok{=}\NormalTok{ others }\OperatorTok{=} \FloatTok{0}
        \ControlFlowTok{for}\NormalTok{ char }\OperatorTok{∈}\NormalTok{ word}
            \FunctionTok{isletter}\NormalTok{(char) ? (letters }\OperatorTok{+=} \FloatTok{1}\NormalTok{) }\OperatorTok{:}\NormalTok{ (}\FunctionTok{isnumeric}\NormalTok{(char) ? (numbers }\OperatorTok{+=} \FloatTok{1}\NormalTok{) }\OperatorTok{:}\NormalTok{ (others }\OperatorTok{+=} \FloatTok{1}\NormalTok{))}
        \ControlFlowTok{end}

        \CommentTok{\# Raises errors if any character types are not represented enough}
\NormalTok{        letters }\OperatorTok{\textless{}} \FloatTok{2} \OperatorTok{\&\&} \FunctionTok{throw}\NormalTok{(}\FunctionTok{ArgumentError}\NormalTok{(}\StringTok{"password must contain at least 2 letters."}\NormalTok{))}
\NormalTok{        numbers }\OperatorTok{\textless{}} \FloatTok{2} \OperatorTok{\&\&} \FunctionTok{throw}\NormalTok{(}\FunctionTok{ArgumentError}\NormalTok{(}\StringTok{"password must contain at least 2 numbers."}\NormalTok{))}
\NormalTok{        others }\OperatorTok{\textless{}} \FloatTok{1} \OperatorTok{\&\&} \FunctionTok{throw}\NormalTok{(}\FunctionTok{ArgumentError}\NormalTok{(}\StringTok{"password must contain at least 1 character other than letters and numbers."}\NormalTok{))}

        \CommentTok{\# If no error, creates the new \textasciigrave{}Password\textasciigrave{}}
        \FunctionTok{new}\DataTypeTok{\{N\}}\NormalTok{(word)}
    \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, colframe=quarto-callout-note-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

The \texttt{where} keyword used here is required when defining
constructors of parametric types. In this instance, we've only needed to
use it to tell Julia to define \texttt{N} locally as the name of a
parameter, rather than trying to substitute in the value of some
variable called \texttt{N}. More uses of \texttt{where} are demonstrated
in Chapter~\ref{sec-multipledispatch}.

\end{tcolorbox}

Let's try this out:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Password}\DataTypeTok{\{8\}}\NormalTok{(}\StringTok{"great"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: ArgumentError: password must contain at least 8 characters.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Password}\DataTypeTok{\{8\}}\NormalTok{(}\StringTok{"fantastic"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: ArgumentError: password must contain at least 2 numbers.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Password}\DataTypeTok{\{8\}}\NormalTok{(}\StringTok{"fanta5t1c"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: ArgumentError: password must contain at least 1 character other than letters and numbers.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Password}\DataTypeTok{\{8\}}\NormalTok{(}\StringTok{"fanta5t1("}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Password{8}("fanta5t1(")
\end{verbatim}

There is more that can be done with inner constructors, including
writing functions with different names to change how the type can be
constructed, or leaving mutable types with some fields uninitialised, to
be added in later, but we'll leave it there for now.

\hypertarget{outer-constructors}{%
\subsection{Outer constructors}\label{outer-constructors}}

The other type of constructor is the \emph{outer constructor}, so called
because they are defined outside of the \texttt{struct} block. These
each take a different pattern of inputs, so that multiple dispatch knows
which to call, and will use another constructor (possibly initially a
sequence of outer constructors, but ultimately the inner constructor has
to be called eventually) to return an instance of the desired type.

We'll use this to add onto our \texttt{Password} type. Instead of coming
up with our own password, let's say that giving an \texttt{Integer}
instead of a \texttt{String} as an argument to the
\texttt{Password\{N\}} constructor will generate a password of that
length for us:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ LETTERS }\OperatorTok{=} \StringTok{"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklnopqrstuvwxyz"}
\KeywordTok{const}\NormalTok{ NUMBERS }\OperatorTok{=} \StringTok{"0123456789"}
\KeywordTok{const}\NormalTok{ SYMBOLS }\OperatorTok{=} \StringTok{"!@\#\textbackslash{}$\%\^{}\&*"}

\ImportTok{using} \BuiltInTok{Random }\CommentTok{\# for the function \textasciigrave{}randperm\textasciigrave{}}

\KeywordTok{function} \FunctionTok{Password}\DataTypeTok{\{N\}}\NormalTok{(n}\OperatorTok{::}\DataTypeTok{Integer}\NormalTok{) }\KeywordTok{where}\NormalTok{ N}
\NormalTok{    n }\OperatorTok{\textless{}} \FloatTok{5} \OperatorTok{\&\&} \FunctionTok{throw}\NormalTok{(}\FunctionTok{ArgumentError}\NormalTok{(}\StringTok{"cannot have a password of length }\SpecialCharTok{$}\NormalTok{n}\StringTok{."}\NormalTok{))}
\NormalTok{    word }\OperatorTok{=} \FunctionTok{*}\NormalTok{(}
        \FunctionTok{rand}\NormalTok{(LETTERS, }\FloatTok{2}\NormalTok{)}\OperatorTok{...}\NormalTok{,}
        \FunctionTok{rand}\NormalTok{(NUMBERS, }\FloatTok{2}\NormalTok{)}\OperatorTok{...}\NormalTok{,}
        \FunctionTok{rand}\NormalTok{(SYMBOLS, }\FloatTok{1}\NormalTok{)}\OperatorTok{...}\NormalTok{,}
        \FunctionTok{rand}\NormalTok{(LETTERS}\OperatorTok{*}\NormalTok{NUMBERS}\OperatorTok{*}\NormalTok{SYMBOLS, n}\OperatorTok{{-}}\FloatTok{5}\NormalTok{)}\OperatorTok{...}
\NormalTok{    )}
    \CommentTok{\# This use of \textasciigrave{}randperm\textasciigrave{} shuffles the characters}
    \CommentTok{\# Otherwise, we\textquotesingle{}d always start with two letters, two numbers, and one symbol}
    \FunctionTok{Password}\DataTypeTok{\{N\}}\NormalTok{(word[}\FunctionTok{randperm}\NormalTok{(n)])}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, colframe=quarto-callout-note-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Nowhere in this constructor have we:

\begin{itemize}
\item
  Said that \texttt{N} needs to be an \texttt{Integer}
\item
  Said that \texttt{n} needs to be at least \texttt{N}
\end{itemize}

These are already handled by the inner constructor, which is what we
call at the end when we give \texttt{Password\{N\}} a single
\texttt{String} argument, so we don't need to do these checks here.
We've also built the random password to ensure that it contains the
requisite character, meaning that it will pass those tests. The only
check we have done, checking that \texttt{n} is at least 5, is to ensure
that the code within the outer constructor doesn't break, specifically
when we try to choose \texttt{n-5} random items later.

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, colframe=quarto-callout-note-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

The \texttt{using} keyword we have used here is to be able to make use
of a \emph{package}, which is an add-on to Julia with extra
functionality, in this case \texttt{Random}. More discussion of packages
can be found in Chapter~\ref{sec-packages}.

\end{tcolorbox}

We can now generate random passwords:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Password}\DataTypeTok{\{8\}}\NormalTok{(}\FloatTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Password{8}("&jc6I89lS3")
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Password}\DataTypeTok{\{8\}}\NormalTok{(}\FloatTok{15}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Password{8}("k2sLw9t!OS#2JBb")
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Password}\DataTypeTok{\{8\}}\NormalTok{(}\FloatTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: ArgumentError: password must contain at least 8 characters.
\end{verbatim}

Outer constructors need not refer directly to inner constructors,
instead we can chain them together. For example, let's suppose that we
don't specify any arguments to \texttt{Password\{N\}}, and we want that
to generate a password of length \texttt{N} (the minimum allowed by
\texttt{Password\{N\}}). We can do this simply by calling our first
outer constructor:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Password}\DataTypeTok{\{N\}}\NormalTok{() }\KeywordTok{where}\NormalTok{ N }\OperatorTok{=} \FunctionTok{Password}\DataTypeTok{\{N\}}\NormalTok{(N)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Password}\DataTypeTok{\{10\}}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Password{10}("C6Knx5k1#g")
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Password}\DataTypeTok{\{15\}}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Password{15}("dxoy7\$fn^BI%%8*")
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Convention}, colframe=quarto-callout-tip-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Inner constructors should be used minimally, only where an outer
constructor could not perform the same task.

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, colframe=quarto-callout-note-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Why are there two different types of constructors anyway? As similar as
they might seem, the two types of constructors perform quite different
roles.

Inner constructors are intended as intrinsic parts of the type, perhaps
enforcing conditions upon the parameters and fields that can't be done
by type declarations as we've seen, although they do have some other
uses particularly with mutable types. Once the type has been defined,
they are set in stone, and cannot be altered or amended.

Outer constructors, meanwhile, are just like methods are to functions.
They can be changed, overwritten, and new ones added at will (although
doing this to inbuilt types might cause problems!) They are more limited
than inner constructors, but their greater flexibility means that
anything possible with an outer constructor should be done with an outer
constructor.

\end{tcolorbox}

\hypertarget{adding-a-display-style}{%
\subsection{Adding a display style}\label{adding-a-display-style}}

When the value of a new type is displayed, the default appearance looks
very much like the inner constructor we use to create it, as we can see
from the \texttt{Password} outputs earlier on. This is deliberate,
automatically allowing for string interpolation, interpretation, and
evaluation by Julia if needed. However, it's not always the most useful
way of showing the value, and in certain self-referential cases, can
break entirely. Therefore, it's valuable to be able to customise this
look, which we can do by overloading (i.e.~writing a new method for) the
inbuilt function \texttt{show}.

Before we write a new method, we need to \texttt{import} the old ones,
so that we don't redefine \texttt{show} accidentally and then nothing
but our new type can be displayed by Julia. \texttt{show} comes from the
module \texttt{Base}, so we use:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{Base.show}
\end{Highlighting}
\end{Shaded}

In Chapter~\ref{sec-multipledispatch}, we'll make further use of
\texttt{import}, while in Chapter~\ref{sec-packages} we'll understand it
a little better.

Now, we can write our own method. The best way to do this is to write a
method with two inputs, one of type \texttt{IO}, and one of our new type
that we want to display. The reason for this is that the \texttt{IO}
argument determines where the output will go, allowing us to display our
value wherever it needs to be displayed.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{show}\NormalTok{(io}\OperatorTok{::}\DataTypeTok{IO}\NormalTok{, x}\OperatorTok{::}\DataTypeTok{[type}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

When outputting the type, there are two function that you'll likely want
to use: \texttt{print} and \texttt{println}. Both take the \texttt{IO}
argument first, followed by a \texttt{String} that you want printed.
Both output this as text to wherever \texttt{IO} tells them to. However,
\texttt{println} also adds a newline character (the equivalent of
pressing \texttt{Enter\ ⮠} on your keyboard) after this message, while
\texttt{print} doesn't, allowing you to keep adding to the same line.
You can use these in combination with other string manipulations (see
Chapter~\ref{sec-strings}).

Unlike other functions, we're not interested in a value being returned
by \texttt{show}. Indeed, the last thing your method will likely do is
call one of \texttt{print} or \texttt{println}, which have no output (or
more accurately, their output is \texttt{nothing}, the value of the
singleton type \texttt{Nothing}), so the same will be true of
\texttt{show}. This is fine, however, as the output that we need is the
printed text, which happens in the middle of the function anyway
regardless of what is returned at the end.

For a quick demonstration of this, let's change the output of our
\texttt{Password} type. Of course, \texttt{Password}s should be secret,
so we don't want to show their value to the world whenever they enquire!
Instead, we'll output \texttt{"•"} in place of each of the characters:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{show}\NormalTok{(io}\OperatorTok{::}\DataTypeTok{IO}\NormalTok{, x}\OperatorTok{::}\DataTypeTok{Password}\NormalTok{) }\OperatorTok{=} \FunctionTok{print}\NormalTok{(io, }\StringTok{"•"}\OperatorTok{\^{}}\FunctionTok{length}\NormalTok{(x.word))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
show (generic function with 380 methods)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Password}\DataTypeTok{\{10\}}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
••••••••••
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Password}\DataTypeTok{\{15\}}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
•••••••••••••••
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, colframe=quarto-callout-note-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Much like functions, types are really just another type of variable.
Their type is \texttt{DataType}, and preceding a \texttt{Tuple} with
their name calls a constructor. Similar to functions, once defined, they
cannot be redefined as anything else.

\end{tcolorbox}

\hypertarget{scope-of-variables}{%
\section{Scope of variables}\label{scope-of-variables}}

Suppose, somewhere deep in the Julia codebase, someone has defined the
variable \texttt{x} (this isn't much of a supposition, it happens
countless times!). When Julia initialises, and this code is run, the
name \texttt{x} is, at some point, used to refer to some value. Wouldn't
it be really annoying if, because of this, no-one was allowed to use the
name \texttt{x} ever again? Or, every time that data is given a name
somewhere in the code, its value is stored in perpetuity, waiting to be
overwritten? This sounds ridiculous, but if it weren't for the system of
variable \emph{scope}, it would be a reality.

The scope of a variable defines where and when its name may be used to
reference its value. Outside of scope, it may refer to a different
defined value (acting as a different variable, but happens to have the
same name in a different context), or give an error saying that it's not
defined.

The scope always starts where the variable in question is first defined,
but pinning down where it ends is trickier. To illustrate this, consider
the following examples:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \FloatTok{0}

\ControlFlowTok{for}\NormalTok{ i }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\FloatTok{2}
\NormalTok{    x }\OperatorTok{=} \FloatTok{1}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
\ControlFlowTok{end}

\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

We start by setting \texttt{x\ =\ 0}, and then run a \texttt{for} loop.
First, it runs with \texttt{i\ =\ 1}, setting the value of \texttt{x} to
\texttt{1}, and then setting \texttt{i} to be \texttt{1}. Then, it runs
with \texttt{i\ =\ 2}, again setting the values of \texttt{x} and
\texttt{i} to \texttt{1}. The loop concludes, and we display the value
of \texttt{x}. Unsurprisingly, perhaps, its value is \texttt{1}. What
about \texttt{i}?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: UndefVarError: `i` not defined
\end{verbatim}

\texttt{i} doesn't have a value at the end of this section of code, even
though the loop finished with \texttt{i\ =\ 1}. This is because the
variable \texttt{i} is defined inside the \texttt{for} loop, so its
scope stops at the keyword \texttt{end} that marks the end of the loop.

Now let's tweak the code slightly, changing the iterated variable from
\texttt{i} to \texttt{x}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \FloatTok{0}

\ControlFlowTok{for}\NormalTok{ x }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\FloatTok{2}
\NormalTok{    x }\OperatorTok{=} \FloatTok{1}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
\ControlFlowTok{end}

\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0
\end{verbatim}

This starts again by setting \texttt{x\ =\ 0}, but then the loop runs
differently. This time, we begin the loop with \texttt{x\ =\ 1}, set the
values of \texttt{x} and \texttt{i} to \texttt{1}, and do the same with
\texttt{x\ =\ 2}. So why isn't the final value of \texttt{x} \texttt{2}?
By defining \texttt{x} as the iterating variable in the \texttt{for}
loop, we've unwittingly created a new variable called \texttt{x} that
belongs only within the loop (a variable that exists only within a
certain block of code like this is \emph{local} to that block).
Therefore, the original \texttt{x} is entirely unaffected. Just as
before, \texttt{i} is only defined within the \texttt{for} loop, so
Julia won't recognise it outside of that:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: UndefVarError: `i` not defined
\end{verbatim}

\hypertarget{code-blocks}{%
\subsection{Code blocks}\label{code-blocks}}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, colframe=quarto-callout-note-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

The diagrams in this section are generated in Julia, and the code used
is given in the functions hidden below. To read them, all you need to
know is:

\begin{itemize}
\tightlist
\item
  Each dot marks where a variable is defined or overwritten
\item
  Solid lines show where a variable is in scope
\item
  Dotted lines show where a variable is temporarily out of scope, with
  the variable name having been reused to define a local variable in a
  new block
\end{itemize}

\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"""}
\StringTok{WARNING}
\StringTok{This code is deliberately scrappy and unoptimised.}
\StringTok{Its only purpose is to generate the diagrams below.}

\StringTok{Known issues}
\StringTok{{-} Code must be correct Julia code (in particular, no missing or unmatched \textasciigrave{}end\textasciigrave{}s)}
\StringTok{{-} Only blocks \textasciigrave{}begin\textasciigrave{}, \textasciigrave{}if\textasciigrave{}, \textasciigrave{}elseif\textasciigrave{}, \textasciigrave{}else\textasciigrave{}, \textasciigrave{}while\textasciigrave{}, \textasciigrave{}for\textasciigrave{}, \textasciigrave{}function\textasciigrave{}, \textasciigrave{}struct\textasciigrave{} can be used}
\StringTok{{-} Functions can\textquotesingle{}t be defined short{-}form (e.g. \textasciigrave{}f(x) = x + 2\textasciigrave{}), they must use \textasciigrave{}function\textasciigrave{} to be recognised}
\StringTok{{-} Variables given as inputs to functions are only detected if they are the first input}
\StringTok{{-} Doesn\textquotesingle{}t deal with branched code (e.g. \textasciigrave{}if\textasciigrave{}{-}statements) properly}
\StringTok{{-} Ignores \textasciigrave{}local\textasciigrave{} and \textasciigrave{}global\textasciigrave{}}

\StringTok{"""}

\ImportTok{using} \BuiltInTok{Plots}

\CommentTok{\# Given a list of lines of code, finds what the indentation level of each should be,}
\CommentTok{\# as well as a list of blocks in which said line is nested}
\KeywordTok{function} \FunctionTok{findstructure}\NormalTok{(code}\OperatorTok{::}\DataTypeTok{Vector\{String\}}\NormalTok{)}
    
\NormalTok{    n }\OperatorTok{=} \FunctionTok{length}\NormalTok{(code)}
\NormalTok{    indents }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{, n)}
\NormalTok{    blocks }\OperatorTok{=} \FunctionTok{fill}\NormalTok{(}\DataTypeTok{String}\NormalTok{[], n}\OperatorTok{+}\FloatTok{1}\NormalTok{)}
    \CommentTok{\# The keywords that mark an indentation. Not comprehensive, e.g. do and let are not included}
\NormalTok{    INDENTORS }\OperatorTok{=}\NormalTok{ [}\StringTok{"begin"}\NormalTok{, }\StringTok{"if "}\NormalTok{, }\StringTok{"while "}\NormalTok{, }\StringTok{"for "}\NormalTok{, }\StringTok{"function "}\NormalTok{, }\StringTok{"struct "}\NormalTok{]}

    \CommentTok{\# Keeps track of the current indent level}
\NormalTok{    rollingindent }\OperatorTok{=} \FloatTok{0}
    \CommentTok{\# Goes line by line, increasing/decreasing indent and updating blocks as it goes}
    \ControlFlowTok{for}\NormalTok{ i }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\NormalTok{n}
        \ControlFlowTok{if}\NormalTok{ code[i] }\OperatorTok{==} \StringTok{"end"}
\NormalTok{            rollingindent }\OperatorTok{{-}=} \FloatTok{1}
\NormalTok{            indents[i] }\OperatorTok{=}\NormalTok{ rollingindent}
            \FunctionTok{pop!}\NormalTok{(blocks[i])}
        \ControlFlowTok{elseif}\NormalTok{ code[i] }\OperatorTok{==} \StringTok{"else"}
\NormalTok{            indents[i] }\OperatorTok{=}\NormalTok{ rollingindent }\OperatorTok{{-}} \FloatTok{1}
        \ControlFlowTok{else}
\NormalTok{            indents[i] }\OperatorTok{=}\NormalTok{ rollingindent}
            \ControlFlowTok{for}\NormalTok{ indentor }\OperatorTok{∈}\NormalTok{ INDENTORS}
                \ControlFlowTok{if} \FunctionTok{startswith}\NormalTok{(code[i], indentor)}
\NormalTok{                    rollingindent }\OperatorTok{+=} \FloatTok{1}
                    \FunctionTok{append!}\NormalTok{(blocks[i], [indentor])}
                \ControlFlowTok{end}
            \ControlFlowTok{end}
        \ControlFlowTok{end}
\NormalTok{        blocks[i}\OperatorTok{+}\FloatTok{1}\NormalTok{] }\OperatorTok{=} \FunctionTok{copy}\NormalTok{(blocks[i])}
    \ControlFlowTok{end}

    \ControlFlowTok{return}\NormalTok{ indents, blocks[}\FloatTok{1}\OperatorTok{:}\NormalTok{n]}
\KeywordTok{end}

\CommentTok{\# Returns a list of \textasciigrave{}Symbol\textasciigrave{}s detailing the scope of a given variable \textasciigrave{}var\textasciigrave{} line by line in the code \textasciigrave{}code\textasciigrave{}}
\CommentTok{\# \textasciigrave{}var\textasciigrave{} is assumed to be defined on line \textasciigrave{}linedefined\textasciigrave{}}
\CommentTok{\# \textasciigrave{}indents\textasciigrave{} and \textasciigrave{}blocks\textasciigrave{} are as from \textasciigrave{}findstructure\textasciigrave{}}
\CommentTok{\#}
\CommentTok{\# Returned \textasciigrave{}Symbol\textasciigrave{}s are:}
\CommentTok{\# {-} :out means out of scope}
\CommentTok{\# {-} :in means in scope}
\CommentTok{\# {-} :def means that the variable is defined (or redefined) on this line}
\CommentTok{\# {-} :paused means that the variable is currently out of scope due to local redefinition}
\KeywordTok{function} \FunctionTok{findscope}\NormalTok{(}
\NormalTok{    var}\OperatorTok{::}\DataTypeTok{Symbol}\NormalTok{,}
\NormalTok{    linedefined}\OperatorTok{::}\DataTypeTok{Int64}\NormalTok{,}
\NormalTok{    code}\OperatorTok{::}\DataTypeTok{Vector\{String\}}\NormalTok{,}
\NormalTok{    indents}\OperatorTok{::}\DataTypeTok{Vector\{Int64\}}\NormalTok{,}
\NormalTok{    blocks}\OperatorTok{::}\DataTypeTok{Vector\{Vector\{String\}\}}
\NormalTok{)}

\NormalTok{    n }\OperatorTok{=} \FunctionTok{length}\NormalTok{(code)}
\NormalTok{    scope }\OperatorTok{=} \FunctionTok{Vector}\DataTypeTok{\{Symbol\}}\NormalTok{(}\ConstantTok{undef}\NormalTok{, n)}

    \PreprocessorTok{@assert} \FloatTok{1} \OperatorTok{≤}\NormalTok{ linedefined }\OperatorTok{≤}\NormalTok{ n}

    \CommentTok{\# The keywords that begin a new scope}
\NormalTok{    BEGIN\_SCOPERS }\OperatorTok{=}\NormalTok{ [}\StringTok{"while "}\NormalTok{, }\StringTok{"for "}\NormalTok{, }\StringTok{"function "}\NormalTok{, }\StringTok{"struct "}\NormalTok{]}
    \CommentTok{\# The keywords that begin a new scope in which the scope of \textasciigrave{}var\textasciigrave{} may be paused}
\NormalTok{    PAUSE\_SCOPERS }\OperatorTok{=}\NormalTok{ [}\StringTok{"for "} \OperatorTok{*} \FunctionTok{string}\NormalTok{(var), }\StringTok{"function "}\NormalTok{, }\StringTok{"struct "}\NormalTok{]}
    
    \CommentTok{\# Set the scope before and at initial definition}
\NormalTok{    scope[}\FloatTok{1}\OperatorTok{:}\NormalTok{(linedefined}\OperatorTok{{-}}\FloatTok{1}\NormalTok{)] }\OperatorTok{.=} \OperatorTok{:}\NormalTok{out}
\NormalTok{    scope[linedefined] }\OperatorTok{=} \OperatorTok{:}\NormalTok{def}

    \CommentTok{\# Finds the indent of the scope in which the variable lies}
\NormalTok{    scopeindent }\OperatorTok{=} \FunctionTok{findlast}\NormalTok{([b }\OperatorTok{∈}\NormalTok{ BEGIN\_SCOPERS for b }\OperatorTok{∈}\NormalTok{ blocks[linedefined]])}
    \FunctionTok{isnothing}\NormalTok{(scopeindent) }\OperatorTok{\&\&}\NormalTok{ (scopeindent }\OperatorTok{=} \FloatTok{0}\NormalTok{)}

    \CommentTok{\# Lists the indentation levels where new scopes have begun}
\NormalTok{    pausableindents }\OperatorTok{=} \DataTypeTok{Int64}\NormalTok{[]}
\NormalTok{    pauseindent }\OperatorTok{=} \FloatTok{0} 
    
    \CommentTok{\# Goes line by line, finding in what state of scope the variable lies at the end of each line}
    \ControlFlowTok{for}\NormalTok{ i }\OperatorTok{∈}\NormalTok{ (linedefined}\OperatorTok{+}\FloatTok{1}\NormalTok{)}\OperatorTok{:}\NormalTok{n}
        \CommentTok{\# If scope is currently paused, check if it has ended yet}
        \ControlFlowTok{if}\NormalTok{ scope[i}\OperatorTok{{-}}\FloatTok{1}\NormalTok{] }\OperatorTok{==} \OperatorTok{:}\NormalTok{paused}
            \ControlFlowTok{if}\NormalTok{ indents[i] }\OperatorTok{==}\NormalTok{ pauseindent}
\NormalTok{                scope[i] }\OperatorTok{=} \OperatorTok{:}\KeywordTok{in}
            \ControlFlowTok{else}
\NormalTok{                scope[i] }\OperatorTok{=} \OperatorTok{:}\NormalTok{paused}
            \ControlFlowTok{end}
        \CommentTok{\# If scope is not paused}
        \ControlFlowTok{else}
            \CommentTok{\# If we exit the block in which the variable is defined, it is out of scope forever}
            \ControlFlowTok{if}\NormalTok{ indents[i] }\OperatorTok{\textless{}}\NormalTok{ scopeindent}
\NormalTok{                scope[i}\OperatorTok{:}\KeywordTok{end}\NormalTok{] }\OperatorTok{.=} \OperatorTok{:}\NormalTok{out}
                \ControlFlowTok{break}
            \CommentTok{\# If we start a new scope, we need to track it by adding its indentation level to \textasciigrave{}pausableindents\textasciigrave{}}
            \ControlFlowTok{elseif} \FunctionTok{any}\NormalTok{(}\FunctionTok{startswith}\NormalTok{.(code[i], PAUSE\_SCOPERS))}
                \FunctionTok{append!}\NormalTok{(pausableindents, indents[i])}
                \CommentTok{\# If our variable isn\textquotesingle{}t defined in a function\textquotesingle{}s arguments, it remains in scope}
                \ControlFlowTok{if} \FunctionTok{startswith}\NormalTok{(code[i], }\StringTok{"function "}\NormalTok{) }\OperatorTok{\&\&}
\NormalTok{                    !}\FunctionTok{startswith}\NormalTok{(code[i], }\FunctionTok{Regex}\NormalTok{(}\StringTok{"function .+}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{("} \OperatorTok{*} \FunctionTok{string}\NormalTok{(var) }\OperatorTok{*} \StringTok{"[,)]"}\NormalTok{))}
\NormalTok{                    scope[i] }\OperatorTok{=} \OperatorTok{:}\KeywordTok{in}                  
                \CommentTok{\# Otherwise, the scope is paused}
                \ControlFlowTok{else}
\NormalTok{                    scope[i] }\OperatorTok{=} \OperatorTok{:}\NormalTok{paused}
\NormalTok{                    pauseindent }\OperatorTok{=} \FunctionTok{pop!}\NormalTok{(pausableindents)}
                \ControlFlowTok{end}
            \CommentTok{\# If our variable is redefined}
            \ControlFlowTok{elseif} \FunctionTok{startswith}\NormalTok{(code[i], }\FunctionTok{string}\NormalTok{(var) }\OperatorTok{*} \StringTok{" ="}\NormalTok{)}
                \CommentTok{\# If this happens in a new scope, then it is locally redefined}
                \ControlFlowTok{if}\NormalTok{ !}\FunctionTok{isempty}\NormalTok{(pausableindents)}
\NormalTok{                    scope[i] }\OperatorTok{=} \OperatorTok{:}\NormalTok{paused}
\NormalTok{                    pauseindent }\OperatorTok{=} \FunctionTok{pop!}\NormalTok{(pausableindents)}
                \CommentTok{\# Otherwise, the value is overwritten}
                \ControlFlowTok{else}
\NormalTok{                    scope[i] }\OperatorTok{=} \OperatorTok{:}\NormalTok{def}
                \ControlFlowTok{end}
            \CommentTok{\# Otherwise, we remain in scope}
            \ControlFlowTok{else}
                \CommentTok{\# If an \textasciigrave{}end\textasciigrave{} keyword ends a new scope, we need to delete it from \textasciigrave{}pausableindents\textasciigrave{}}
                \ControlFlowTok{if}\NormalTok{ code[i] }\OperatorTok{==} \StringTok{"end"} \OperatorTok{\&\&}
\NormalTok{                    !}\FunctionTok{isempty}\NormalTok{(pausableindents) }\OperatorTok{\&\&}
\NormalTok{                    indents[i] }\OperatorTok{==}\NormalTok{ pausableindents[}\KeywordTok{end}\NormalTok{]}
                    
                    \FunctionTok{pop!}\NormalTok{(pausableindents)}
                \ControlFlowTok{end}
\NormalTok{                scope[i] }\OperatorTok{=} \OperatorTok{:}\KeywordTok{in}
            \ControlFlowTok{end}
        \ControlFlowTok{end}
    \ControlFlowTok{end}
    
    \ControlFlowTok{return}\NormalTok{ scope}
\KeywordTok{end}

\CommentTok{\# Creates a diagram detailing the scope of variables in \textasciigrave{}vars\textasciigrave{} defined on lines \textasciigrave{}linesdefined\textasciigrave{} of code \textasciigrave{}code\textasciigrave{}}
\KeywordTok{function} \FunctionTok{scopediagram}\NormalTok{(}
\NormalTok{    vars}\OperatorTok{::}\DataTypeTok{Vector\{Symbol\}}\NormalTok{,}
\NormalTok{    linesdefined}\OperatorTok{::}\DataTypeTok{Vector\{Int64\}}\NormalTok{,}
\NormalTok{    code}\OperatorTok{::}\DataTypeTok{Vector\{String\}}
\NormalTok{)}

\NormalTok{    n }\OperatorTok{=} \FunctionTok{length}\NormalTok{(code)}
\NormalTok{    nvars }\OperatorTok{=} \FunctionTok{length}\NormalTok{(vars)}
\NormalTok{    nvars }\OperatorTok{==} \FunctionTok{length}\NormalTok{(linesdefined) }\OperatorTok{||} \FunctionTok{error}\NormalTok{(}\StringTok{"mismatched number of variables and lines where they are defined"}\NormalTok{)}
\NormalTok{    nvars }\OperatorTok{\textgreater{}} \FloatTok{4} \OperatorTok{\&\&} \FunctionTok{error}\NormalTok{(}\StringTok{"can draw scope of at most 4 variables at a time"}\NormalTok{)}

\NormalTok{    p }\OperatorTok{=} \FunctionTok{plot}\NormalTok{(}
\NormalTok{        framestyle }\OperatorTok{=} \OperatorTok{:}\NormalTok{origin,}
\NormalTok{        size }\OperatorTok{=}\NormalTok{ (}\FloatTok{400}\NormalTok{, }\FloatTok{18}\NormalTok{n),}
\NormalTok{        grid }\OperatorTok{=} \ConstantTok{false}\NormalTok{,}
\NormalTok{        legend }\OperatorTok{=} \ConstantTok{false}\NormalTok{,}
\NormalTok{        showaxis }\OperatorTok{=} \ConstantTok{false}\NormalTok{,}
\NormalTok{        ticks }\OperatorTok{=} \ConstantTok{false}\NormalTok{,}
\NormalTok{        xlims }\OperatorTok{=}\NormalTok{ (}\FloatTok{0}\NormalTok{, }\FloatTok{40}\NormalTok{),}
\NormalTok{        ylims }\OperatorTok{=}\NormalTok{ (}\OperatorTok{{-}}\NormalTok{n, }\FloatTok{0}\NormalTok{)}
\NormalTok{    )}

\NormalTok{    indents, blocks }\OperatorTok{=} \FunctionTok{findstructure}\NormalTok{(code)}

    \CommentTok{\# Writes the code with correct indentations}
    \FunctionTok{plot!}\NormalTok{(}
\NormalTok{        annotations }\OperatorTok{=}\NormalTok{ [}
\NormalTok{            (}\FloatTok{1} \OperatorTok{+}\NormalTok{ nvars }\OperatorTok{+} \FloatTok{2}\NormalTok{indents[i], }\FloatTok{0.5}\OperatorTok{{-}}\NormalTok{i, (code[i], }\FloatTok{8}\NormalTok{, }\OperatorTok{:}\NormalTok{black, }\OperatorTok{:}\NormalTok{left), }\StringTok{"courier"}\NormalTok{)}
\NormalTok{        for i }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\NormalTok{n]}
\NormalTok{    )}

\NormalTok{    cs }\OperatorTok{=}\NormalTok{ [}\OperatorTok{:}\NormalTok{lime, }\OperatorTok{:}\NormalTok{skyblue, }\OperatorTok{:}\NormalTok{orange, }\OperatorTok{:}\NormalTok{pink]}

    \CommentTok{\# Draws the scope of each of the variables}
    \ControlFlowTok{for}\NormalTok{ j }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\NormalTok{nvars}
\NormalTok{        scope }\OperatorTok{=} \FunctionTok{findscope}\NormalTok{(vars[j], linesdefined[j], code, indents, blocks)}
    
        \CommentTok{\# Dots for (re)definitions}
        \FunctionTok{scatter!}\NormalTok{(}
\NormalTok{            [(j}\OperatorTok{{-}}\FloatTok{0.5}\NormalTok{, }\FloatTok{0.5}\OperatorTok{{-}}\NormalTok{i)}
\NormalTok{                for i }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\NormalTok{n if scope[i] }\OperatorTok{==} \OperatorTok{:}\NormalTok{def],}
\NormalTok{            markercolor }\OperatorTok{=}\NormalTok{ cs[j],}
\NormalTok{            markerstrokecolor }\OperatorTok{=}\NormalTok{ cs[j]}
\NormalTok{        )}
        
        \CommentTok{\# Filled line for in scope}
        \FunctionTok{plot!}\NormalTok{(}
\NormalTok{            [}\FunctionTok{Shape}\NormalTok{([j}\OperatorTok{{-}}\FloatTok{0.6}\NormalTok{, j}\OperatorTok{{-}}\FloatTok{0.4}\NormalTok{, j}\OperatorTok{{-}}\FloatTok{0.4}\NormalTok{, j}\OperatorTok{{-}}\FloatTok{0.6}\NormalTok{], [}\FloatTok{1}\OperatorTok{{-}}\NormalTok{i, }\FloatTok{1}\OperatorTok{{-}}\NormalTok{i, }\OperatorTok{{-}}\NormalTok{i, }\OperatorTok{{-}}\NormalTok{i])}
\NormalTok{                for i }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\NormalTok{n if scope[i] }\OperatorTok{==} \OperatorTok{:}\KeywordTok{in}\NormalTok{],}
\NormalTok{            fillcolor }\OperatorTok{=}\NormalTok{ cs[j],}
\NormalTok{            linecolor }\OperatorTok{=}\NormalTok{ cs[j]}
\NormalTok{        )}
    
        \CommentTok{\# Dotted line for paused scope}
        \FunctionTok{plot!}\NormalTok{(}
\NormalTok{            [}\FunctionTok{Shape}\NormalTok{([j}\OperatorTok{{-}}\FloatTok{0.6}\NormalTok{, j}\OperatorTok{{-}}\FloatTok{0.4}\NormalTok{, j}\OperatorTok{{-}}\FloatTok{0.4}\NormalTok{, j}\OperatorTok{{-}}\FloatTok{0.6}\NormalTok{], [}\FloatTok{1}\OperatorTok{{-}}\NormalTok{i, }\FloatTok{1}\OperatorTok{{-}}\NormalTok{i, }\OperatorTok{{-}}\NormalTok{i, }\OperatorTok{{-}}\NormalTok{i])}
\NormalTok{                for i }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\NormalTok{n if scope[i] }\OperatorTok{==} \OperatorTok{:}\NormalTok{paused],}
\NormalTok{            fillcolor }\OperatorTok{=}\NormalTok{ cs[j],}
\NormalTok{            linecolor }\OperatorTok{=} \OperatorTok{:}\NormalTok{white,}
\NormalTok{            fillstyle }\OperatorTok{=} \OperatorTok{:}\NormalTok{x}
\NormalTok{        )}

        \CommentTok{\# Key}
        \FunctionTok{scatter!}\NormalTok{(}
\NormalTok{            (}\FloatTok{35}\NormalTok{, }\FloatTok{0.5}\OperatorTok{{-}}\NormalTok{j),}
\NormalTok{            markercolor }\OperatorTok{=}\NormalTok{ cs[j],}
\NormalTok{            markerstrokecolor }\OperatorTok{=}\NormalTok{ cs[j],}
\NormalTok{            annotations }\OperatorTok{=}\NormalTok{ (}\FloatTok{36}\NormalTok{, }\FloatTok{0.5}\OperatorTok{{-}}\NormalTok{j, (}\FunctionTok{string}\NormalTok{(vars[j]), }\FloatTok{8}\NormalTok{, }\OperatorTok{:}\NormalTok{black, }\OperatorTok{:}\NormalTok{left), }\StringTok{"courier"}\NormalTok{)}
\NormalTok{        )}
    \ControlFlowTok{end}

    \ControlFlowTok{return}\NormalTok{ p}
\KeywordTok{end}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

By default, every code block (that is, one of the pieces of code that
begins with a codeword such as \texttt{if} or \texttt{function}, and
ends with \texttt{end}) has its own behaviour with respect to the scope
of variables defined outside/inside of it. We'll examine the ones we've
met so far, as well as a couple that we'll meet later.

\texttt{begin}-\texttt{end} is the simplest code block, and has perhaps
the simplest scope behaviour, in that it has no effect on scope.
Anything defined inside it can be accessed on the outside, and vice
versa.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{scopediagram}\NormalTok{(}
\NormalTok{    [}\OperatorTok{:}\NormalTok{x, }\OperatorTok{:}\NormalTok{y], [}\FloatTok{1}\NormalTok{, }\FloatTok{3}\NormalTok{],}
\NormalTok{    [}
        \StringTok{"x = 1"}\NormalTok{,}
        \StringTok{"begin"}\NormalTok{,}
        \StringTok{"y = 2"}\NormalTok{,}
        \StringTok{"x = y"}\NormalTok{,}
        \StringTok{"end"}\NormalTok{,}
        \StringTok{""}\NormalTok{,}
        \StringTok{"x"}\NormalTok{,}
        \StringTok{"y"}
\NormalTok{    ]}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/basics/custom-structures/custom-structures_files/figure-pdf/cell-92-output-1.pdf}

}

\end{figure}

Similarly, \texttt{if}-statements have no special effect on scope. The
same is true for its replacements \texttt{"?\ :"}, \texttt{"\&\&"}, and
\texttt{"\textbar{}\textbar{}"}, although these aren't really code
blocks in and of themselves.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{scopediagram}\NormalTok{(}
\NormalTok{    [}\OperatorTok{:}\NormalTok{x,}\OperatorTok{:}\NormalTok{y], [}\FloatTok{1}\NormalTok{,}\FloatTok{6}\NormalTok{],}
\NormalTok{    [}
        \StringTok{"x = 0"}\NormalTok{,}
        \StringTok{"if x \textgreater{} 3"}\NormalTok{,}
        \StringTok{"y = 1"}\NormalTok{,}
        \StringTok{"x = 2"}\NormalTok{,}
        \StringTok{"else"}\NormalTok{,}
        \StringTok{"y = 2"}\NormalTok{,}
        \StringTok{"x = 1"}\NormalTok{,}
        \StringTok{"end"}\NormalTok{,}
        \StringTok{""}\NormalTok{,}
        \StringTok{"x"}\NormalTok{,}
        \StringTok{"y"}
\NormalTok{    ]}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/basics/custom-structures/custom-structures_files/figure-pdf/cell-93-output-1.pdf}

}

\end{figure}

However, since \texttt{if}-statements give branching paths, it's
possible to miss the definition of a variable, like \texttt{y} in the
example below, so the query of the value of \texttt{y} later will cause
an \texttt{UndefVarError}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{scopediagram}\NormalTok{(}
\NormalTok{    [}\OperatorTok{:}\NormalTok{x], [}\FloatTok{1}\NormalTok{],}
\NormalTok{    [}
        \StringTok{"x = 0"}\NormalTok{,}
        \StringTok{"if x \textgreater{} 3"}\NormalTok{,}
        \StringTok{"y = 1"}\NormalTok{,}
        \StringTok{"x = 2"}\NormalTok{,}
        \StringTok{"end"}\NormalTok{,}
        \StringTok{""}\NormalTok{,}
        \StringTok{"x"}\NormalTok{,}
        \StringTok{"y"}
\NormalTok{    ]}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/basics/custom-structures/custom-structures_files/figure-pdf/cell-94-output-1.pdf}

}

\end{figure}

\texttt{while} and \texttt{for} blocks can reference and update any
variable that was defined before they began. Anything defined for the
first time within them, however, is local to the loop, and is lost as
soon as the loop ends.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{scopediagram}\NormalTok{(}
\NormalTok{    [}\OperatorTok{:}\NormalTok{x, }\OperatorTok{:}\NormalTok{y], [}\FloatTok{1}\NormalTok{, }\FloatTok{2}\NormalTok{],}
\NormalTok{    [}
        \StringTok{"x = 2"}\NormalTok{,}
        \StringTok{"for y ∈ 1:3"}\NormalTok{,}
        \StringTok{"y = x\^{}2"}\NormalTok{,}
        \StringTok{"x = y"}\NormalTok{,}
        \StringTok{"end"}\NormalTok{,}
        \StringTok{""}\NormalTok{,}
        \StringTok{"x"}\NormalTok{,}
        \StringTok{"y"}
\NormalTok{    ]}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/basics/custom-structures/custom-structures_files/figure-pdf/cell-95-output-1.pdf}

}

\end{figure}

A special case exists for the variable or variables that are iterated
through many values by the \texttt{for} loop. These are considered new
local variables regardless of whether they have been defined before or
not.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{scopediagram}\NormalTok{(}
\NormalTok{    [}\OperatorTok{:}\NormalTok{x, }\OperatorTok{:}\NormalTok{x, }\OperatorTok{:}\NormalTok{y], [}\FloatTok{1}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{],}
\NormalTok{    [}
        \StringTok{"x = 2"}\NormalTok{,}
        \StringTok{"for x ∈ 1:3"}\NormalTok{,}
        \StringTok{"y = x\^{}2"}\NormalTok{,}
        \StringTok{"x = y"}\NormalTok{,}
        \StringTok{"end"}\NormalTok{,}
        \StringTok{""}\NormalTok{,}
        \StringTok{"x"}\NormalTok{,}
        \StringTok{"y"}
\NormalTok{    ]}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/basics/custom-structures/custom-structures_files/figure-pdf/cell-96-output-1.pdf}

}

\end{figure}

Note here that the period when the original \texttt{x} is temporarily
out of scope exactly corresponds to when the other \texttt{x} is in
scope (perhaps unsurprisingly).

For a \texttt{function}, any variables defined within the function are
local to the function, but simply referencing a variable from outside
the function works fine because it remains in scope.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{scopediagram}\NormalTok{(}
\NormalTok{    [}\OperatorTok{:}\NormalTok{x, }\OperatorTok{:}\NormalTok{x, }\OperatorTok{:}\NormalTok{y, }\OperatorTok{:}\NormalTok{z], [}\FloatTok{1}\NormalTok{, }\FloatTok{4}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{],}
\NormalTok{    [}
        \StringTok{"x = 4"}\NormalTok{,}
        \StringTok{"function f(y)"}\NormalTok{,}
            \StringTok{"z = x"}\NormalTok{,}
            \StringTok{"x = y {-} z"}\NormalTok{,}
            \StringTok{"y = x\^{}2"}\NormalTok{,}
            \StringTok{"return y + z"}\NormalTok{,}
        \StringTok{"end"}\NormalTok{,}
        \StringTok{""}\NormalTok{,}
        \StringTok{"x"}\NormalTok{,}
        \StringTok{"y"}\NormalTok{,}
        \StringTok{"z"}
\NormalTok{    ]}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/basics/custom-structures/custom-structures_files/figure-pdf/cell-97-output-1.pdf}

}

\end{figure}

Meanwhile, for a \texttt{struct}, variables defined outside can't be
referenced inside, and no variables defined inside can be referenced
outside.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{scopediagram}\NormalTok{(}
\NormalTok{    [}\OperatorTok{:}\NormalTok{x, }\OperatorTok{:}\NormalTok{y], [}\FloatTok{1}\NormalTok{, }\FloatTok{4}\NormalTok{],}
\NormalTok{    [}
        \StringTok{"x = 0"}\NormalTok{,}
        \StringTok{"struct A"}\NormalTok{,}
        \StringTok{"y::Int64"}\NormalTok{,}
        \StringTok{"A(y) = new(x + y)"}\NormalTok{,}
        \StringTok{"end"}\NormalTok{,}
        \StringTok{""}\NormalTok{,}
        \StringTok{"x"}\NormalTok{,}
        \StringTok{"y"}
\NormalTok{    ]}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/basics/custom-structures/custom-structures_files/figure-pdf/cell-98-output-1.pdf}

}

\end{figure}

Scope works in a nested fashion, for example a variable defined inside a
\texttt{begin}-\texttt{end} that itself is inside a \texttt{for} loop
will not be accessible outside the \texttt{for} loop, like \texttt{y}
below.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{scopediagram}\NormalTok{(}
\NormalTok{    [}\OperatorTok{:}\NormalTok{x, }\OperatorTok{:}\NormalTok{y], [}\FloatTok{1}\NormalTok{, }\FloatTok{3}\NormalTok{],}
\NormalTok{    [}
        \StringTok{"for x ∈ 1:2"}\NormalTok{,}
        \StringTok{"begin"}\NormalTok{,}
        \StringTok{"y = 1"}\NormalTok{,}
        \StringTok{"end"}\NormalTok{,}
        \StringTok{"y = x"}\NormalTok{,}
        \StringTok{"x = 1"}\NormalTok{,}
        \StringTok{"end"}\NormalTok{,}
        \StringTok{""}\NormalTok{,}
        \StringTok{"x"}\NormalTok{,}
        \StringTok{"y"}
\NormalTok{    ]}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/basics/custom-structures/custom-structures_files/figure-pdf/cell-99-output-1.pdf}

}

\end{figure}

\hypertarget{local-and-global}{%
\subsection{\texorpdfstring{\texttt{local} and
\texttt{global}}{local and global}}\label{local-and-global}}

For more control over the scope in which your variables exist, you may
wish to use the keywords \texttt{local} and \texttt{global}. These
keywords go before a definition or reassignment of a variable, marking
its scope explicitly:

\begin{itemize}
\item
  Using \texttt{local\ x} creates a new local variable with the name
  \texttt{x}, with scope restricted to the block it is defined in. This
  is how the iterating variable of a \texttt{for} loop is defined (even
  though we didn't type \texttt{local}), and so is why it behaves
  differently to any other variable in a \texttt{for} loop
\item
  Using \texttt{global\ x} declares that this variable name is a
  \emph{global} variable, which means that whenever the name is used, it
  refers to the same variable (except where an explicitly \texttt{local}
  variable called \texttt{x} exists). If, in a large file,
  \texttt{global\ x} is written anywhere, it applies to the whole file,
  not just the references further down the page
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Convention}, colframe=quarto-callout-tip-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Both of these are situationally useful, but particularly the use of
\texttt{global} should be avoided most of the time, as it can have
unexpected effects on other bits of supposedly unrelated code. Instead,
the value can be passed around between functions as an additional
argument, or for unchanging values, a constant (\texttt{const}) variable
can be used.

\end{tcolorbox}

There are some differences in behaviour between the REPL and code run
from \texttt{.jl} files when it comes to \texttt{local} and
\texttt{global} variables. In general, the REPL allows more flexibility,
while \texttt{.jl} code will produce warnings about clumsy use of
\texttt{global} variables. If code is mostly contained within functions
in \texttt{.jl} files (as is advised), no variable will be automatically
\texttt{global}, so this isn't a major worry.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, colframe=quarto-callout-note-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Technically, global variables are not truly global, instead their scope
is the \emph{module} in which they lie. Modules are a way to group
related code together under a single name, and can be convenient for
sharing code.

If no module is ever declared, code will run in \texttt{Main}, so
variables will be functionally global. However, \texttt{global}
variables from other modules (such as from installed packages, see
Chapter~\ref{sec-packages}) would not be accessible, and any
\texttt{global} variables you declare won't affect identically named
variables in these other modules.

\end{tcolorbox}

\hypertarget{constants}{%
\subsection{Constants}\label{constants}}

Constants are a special type of variable, intended to have a single
unchanging value which can be accessed from anywhere (i.e.~a global
scope). For example, you could be running a business that want to make a
4.3\% profit on anything it sells, so you might declare:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ PROFIT\_MARGIN }\OperatorTok{=} \FloatTok{1.043}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1.043
\end{verbatim}

Then, anywhere else in your program, you could refer to
\texttt{PROFIT\_MARGIN}, instead of having to remember what its value is
(provided that the variable name \texttt{PROFIT\_MARGIN} isn't taken by
another value).

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Convention}, colframe=quarto-callout-tip-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

\texttt{const} variables are named differently from normal variables,
instead using capital letters with words separated by underscores. One
good reason to do this is ensure it keeps its global scope, for
instance, if we called our constant \texttt{p}, then it wouldn't be
accessible inside a function that had an input called \texttt{p}.

\end{tcolorbox}

To demonstrate how constants differ from normal variables, consider the
following example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{N }\OperatorTok{=} \FloatTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{addN}\NormalTok{(x) }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+}\NormalTok{ N}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
addN (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{addN}\NormalTok{(}\FloatTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{N }\OperatorTok{=} \FloatTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{addN}\NormalTok{(}\FloatTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6
\end{verbatim}

With the non-constant value \texttt{N}, the function \texttt{addN} looks
up the value of \texttt{N} in order to add it each time it is needed.
However, if we use constants:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ M }\OperatorTok{=} \FloatTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{addM}\NormalTok{(x) }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+}\NormalTok{ M}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
addM (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{addM}\NormalTok{(}\FloatTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ M }\OperatorTok{=} \FloatTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
WARNING: redefinition of constant M. This may fail, cause incorrect answers, or produce other errors.
\end{verbatim}

\begin{verbatim}
4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{addM}\NormalTok{(}\FloatTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5
\end{verbatim}

Now, the \texttt{const} value \texttt{M} is included in the function
verbatim, and since we never redefined the function after that, it's
still expecting \texttt{M} to be the same as it was originally. Notice
that we were warned of exactly this issue when we changed the value of
the constant.

In fact, most of the time, trying to change the value of a
\texttt{const} won't give a warning, it will just result in an error
message, with the value not being changed. Earlier, we noted that
functions and types are actually just \texttt{const} variables of a
form, and you'll note that you won't be able to change their values:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{Int64} \OperatorTok{=} \FloatTok{12}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: cannot assign a value to imported variable Core.Int64 from module Main
\end{verbatim}

There are good reasons you may want to use \texttt{const}s, for values
that you want to define programmatically but never change; some examples
built into Julia are the mathematical constants \texttt{π}, \texttt{ℯ},
etc. As we've seen though, it's necessary to ensure that these constants
are never redefined, they really should be constant!

\hypertarget{example-unit-conversion}{%
\section{Example: Unit conversion}\label{example-unit-conversion}}

A common problem to come across is the need to convert some quantity
between units. There are many online tools that do this, but let's put
some of our new knowledge to the test and create our own crude tool to
do the same. There are many ways to approach this, but we'll be creating
a type to represent a unit, as well as a function to convert between
them.

We'll start with creating a \texttt{Unit} type to represent the units we
want to convert between.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Unit}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

What fields do we need? We need a conversion factor to be able to
convert between units, which will be relative to some standard unit,
such as the
\href{https://en.wikipedia.org/wiki/International_System_of_Units}{SI
units}, and this will be some sort of number. Since we don't know
exactly what type it will be, and we don't particularly mind, we can use
the abstract type \texttt{Real} as an umbrella term. Also, we need to
know what quantity the unit measures, as we can't convert between a unit
of length and a unit of mass, for example! This could come in various
forms, but the simplest will be just to store this as a \texttt{String}.
For the purposes of this example, we won't need any more fields, but for
more functionality you may wish to add others.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Unit}
\NormalTok{    factor}\OperatorTok{::}\DataTypeTok{Real}
\NormalTok{    quantity}\OperatorTok{::}\DataTypeTok{String}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We haven't used an inner constructor here, but we will add some outer
constructors to allow for easier construction of new units. First, we've
mentioned the idea of a base unit, to which all the factors are
relative. We would represent this as a \texttt{Unit} with a
\texttt{factor} of \texttt{1}, so let's add a constructor where if the
\texttt{factor} isn't specified, it's assumed to be \texttt{1}, giving
the base unit:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Unit}\NormalTok{(quantity}\OperatorTok{::}\DataTypeTok{String}\NormalTok{) }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{1}\NormalTok{, quantity)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Unit
\end{verbatim}

When we think of the way that units are usually defined to us, it's
generally in terms of another unit that measures the same thing (i.e.~1
kilometre is 1000 metres). We can add this as a constructor too, using
the \texttt{factor} of an old \texttt{Unit} to calculate the new
\texttt{factor}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Creates the new unit corresponding to x lots of u}
\FunctionTok{Unit}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Real}\NormalTok{, u}\OperatorTok{::}\DataTypeTok{Unit}\NormalTok{) }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(x }\OperatorTok{*}\NormalTok{ u.factor, u.quantity)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Unit
\end{verbatim}

Now that our type is defined, we can create some variables of this type.
For example, here are some units of length:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{metre }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\StringTok{"length"}\NormalTok{)}
\NormalTok{kilometre }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{1000}\NormalTok{, metre)}
\NormalTok{centimetre }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{1}\OperatorTok{//}\FloatTok{100}\NormalTok{, metre)}
\NormalTok{inch }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{2.54}\NormalTok{, centimetre)}
\NormalTok{foot }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{12}\NormalTok{, inch)}
\NormalTok{yard }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{3}\NormalTok{, foot)}
\NormalTok{mile }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{1760}\NormalTok{, yard)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Unit(1609.3440000000003, "length")
\end{verbatim}

some of mass:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{kilogram }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\StringTok{"mass"}\NormalTok{)}
\NormalTok{gram }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{1}\OperatorTok{//}\FloatTok{1000}\NormalTok{, kilogram)}
\NormalTok{pound }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{453.59237}\NormalTok{, gram)}
\NormalTok{ounce }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{1}\OperatorTok{//}\FloatTok{16}\NormalTok{, pound)}
\NormalTok{shortton }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{2000}\NormalTok{, pound)}
\NormalTok{longton }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{2240}\NormalTok{, pound)}
\NormalTok{metricton }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{1000}\NormalTok{, kilogram)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Unit(1000, "mass")
\end{verbatim}

some of time:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{second }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\StringTok{"time"}\NormalTok{)}
\NormalTok{minute }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{60}\NormalTok{, second)}
\NormalTok{hour }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{60}\NormalTok{, minute)}
\NormalTok{day }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{24}\NormalTok{, hour)}
\NormalTok{julianyear }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{365.25}\NormalTok{, day)}
\NormalTok{gregorianyear }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{365.2425}\NormalTok{, day)}
\NormalTok{tropicalyear }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{365.24219}\NormalTok{, day)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Unit(3.1556925216e7, "time")
\end{verbatim}

and some of angles:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{radian }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\StringTok{"angle"}\NormalTok{)}
\NormalTok{fullcircle }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{2}\NormalTok{π, radian)}
\NormalTok{degree }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{1}\OperatorTok{//}\FloatTok{360}\NormalTok{, fullcircle)}
\NormalTok{arcminute }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{1}\OperatorTok{//}\FloatTok{60}\NormalTok{, degree)}
\NormalTok{arcsecond }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{1}\OperatorTok{//}\FloatTok{60}\NormalTok{, arcminute)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Unit(4.84813681109536e-6, "angle")
\end{verbatim}

As is often done with \texttt{Unit}s, we may wish to combine them
together to make new ones, such as combining \texttt{metre} and
\texttt{second} to get \texttt{metrepersecond} measuring
\texttt{"speed"}. Although our implementation doesn't allow for this
automatically (we'd have to tell it that dividing a unit of
\texttt{"length"} by a unit of \texttt{"time"} gives a unit of
\texttt{"speed"}, etc.), we can do this manually:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{metrepersecond }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\StringTok{"speed"}\NormalTok{)}
\CommentTok{\# Speed of light in a vacuum}
\KeywordTok{const}\NormalTok{ C }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{299792458}\NormalTok{, metrepersecond)}

\CommentTok{\# One lightyear is the distance travelled by light in a vacuum in one Julian year}
\CommentTok{\# Calculated by distance = speed * time}
\NormalTok{lightyear }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(C.factor }\OperatorTok{*}\NormalTok{ julianyear.factor, metre)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Unit(9.4607304725808e15, "length")
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# One astronomical unit (au) is approximately the average distance between the Earth and the Sun}
\NormalTok{au }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{149597870700}\NormalTok{, metre)}

\CommentTok{\# One parsec is approximately the distance to an object of parallax angle 1 arcsecond (1//3600 degrees)}
\NormalTok{parsec }\OperatorTok{=} \FunctionTok{Unit}\NormalTok{(}\FloatTok{1}\OperatorTok{/}\NormalTok{arcsecond.factor, au)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Unit(3.085677581491367e16, "length")
\end{verbatim}

Now let's write a function to convert between units. We need three
inputs, the amount to convert, the \texttt{Unit} that this amount is in,
and the \texttt{Unit} to convert it into.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{convertunits}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Real}\NormalTok{, u₁}\OperatorTok{::}\DataTypeTok{Unit}\NormalTok{, u₂}\OperatorTok{::}\DataTypeTok{Unit}\NormalTok{)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-warning-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Warning}, colframe=quarto-callout-warning-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

The natural choice of function name here would be \texttt{convert}, but
this is a crucial function used by Julia to convert between types, so we
don't want to overwrite that. Theoretically, we could use multiple
dispatch (Chapter~\ref{sec-multipledispatch}) to write our own method,
but that would be bad practice, as the \texttt{convert} function is
specifically meant for converting between types and nothing else.

\end{tcolorbox}

First, we need to check that the \texttt{Unit}s entered are compatible,
namely that they measure the same quantity. This can be done by an
\texttt{if}-statement, or even simpler, short-circuited, with an error
displayed if the quantities do not match:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{u₁.quantity }\OperatorTok{==}\NormalTok{ u₂.quantity }\OperatorTok{||} \FunctionTok{throw}\NormalTok{(}\FunctionTok{ArgumentError}\NormalTok{(}\StringTok{"units measure different quantities."}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Now we just need to do the conversion. A little thinking (or
experimenting) tells us that the correct formula for this is to multiply
\texttt{x} by the \texttt{factor} of \texttt{u₁}, and then divide by the
\texttt{factor} of \texttt{u₂}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{*}\NormalTok{ u₁.factor }\OperatorTok{/}\NormalTok{ u₂.factor}
\end{Highlighting}
\end{Shaded}

This is the value we want, so we return it, finishing the function.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{convertunits}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Real}\NormalTok{, u₁}\OperatorTok{::}\DataTypeTok{Unit}\NormalTok{, u₂}\OperatorTok{::}\DataTypeTok{Unit}\NormalTok{)}
\NormalTok{    u₁.quantity }\OperatorTok{==}\NormalTok{ u₂.quantity }\OperatorTok{||} \FunctionTok{throw}\NormalTok{(}\FunctionTok{ArgumentError}\NormalTok{(}\StringTok{"units measure different quantities."}\NormalTok{))}
\NormalTok{    x }\OperatorTok{*}\NormalTok{ u₁.factor }\OperatorTok{/}\NormalTok{ u₂.factor}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
convertunits (generic function with 1 method)
\end{verbatim}

Now we can put this function to the test:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{convertunits}\NormalTok{(}\FloatTok{110}\NormalTok{, kilometre, mile)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
68.35083114610673
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{convertunits}\NormalTok{(}\FloatTok{45}\NormalTok{, degree, radian)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.7853981633974483
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{convertunits}\NormalTok{(}\FloatTok{28}\NormalTok{, day, minute)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
40320.0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{convertunits}\NormalTok{(}\FloatTok{1}\NormalTok{, parsec, lightyear)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3.2615637771674333
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{convertunits}\NormalTok{(}\FloatTok{1}\NormalTok{, metricton, longton)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.9842065276110605
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{convertunits}\NormalTok{(}\FloatTok{12}\NormalTok{, inch, pound)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: ArgumentError: units measure different quantities.
\end{verbatim}

As mentioned, there are other ways of approaching this problem, and ways
of improving this method further. Some ideas for improvement that you
might want to try yourself are:

\begin{itemize}
\item
  The \texttt{quantity} field of \texttt{Unit} is used to check if two
  \texttt{Unit}s measure the same thing, but perhaps could do with an
  inner constructor to constrain the values that we're allowed to put in
  it (e.g.~only \texttt{"length"}, \texttt{"mass"}, \texttt{"time"},
  etc)
\item
  Since this type only uses multiplicative factors, it won't work for
  unit conversion between degrees Celsius and degrees Fahrenheit. You
  could alter the \texttt{Unit} type to account for such an offset
\item
  Using multiple dispatch (see Chapter~\ref{sec-multipledispatch}), we
  can write our own methods for inbuilt Julia functions. For example, a
  method for \texttt{show} can make the displayed output nicer, a method
  for \texttt{*} would allow clean syntax like
  \texttt{inch\ =\ 2.54\ *\ centimetre}, and a method for \texttt{+}
  could allow quantities like 2 years and 5 months
\item
  Instead of using types, we could use a different structure to
  represent units. If you've read Chapter~\ref{sec-arrays}, you may want
  to consider using a \texttt{Dict} for a similar purpose
\end{itemize}

\hypertarget{sec-multipledispatch}{%
\chapter{Multiple dispatch}\label{sec-multipledispatch}}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-important-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Prerequisites}, colframe=quarto-callout-important-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Before reading this chapter, you are recommended to have read
Chapter~\ref{sec-fundamentals} and Chapter~\ref{sec-customstructures}

\end{tcolorbox}

\begin{itemize}
\item
  Type graph
\item
  Types/functions recap
\item
  Methods (with input type specification)
\item
  Promotion
\item
  Adding methods to inbuilt functions
\end{itemize}

\hypertarget{sec-packages}{%
\chapter{Using packages}\label{sec-packages}}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-important-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Prerequisites}, colframe=quarto-callout-important-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Before reading this chapter, you are recommended to have read
Chapter~\ref{sec-fundamentals}

\end{tcolorbox}

\hypertarget{sec-arrays}{%
\chapter{Collections of values}\label{sec-arrays}}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-important-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Prerequisites}, colframe=quarto-callout-important-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Before reading this chapter, you are recommended to have read
Chapter~\ref{sec-fundamentals}, Chapter~\ref{sec-controlflow}, and
Chapter~\ref{sec-customstructures}.

\end{tcolorbox}

While we've seen how to perform many computations so far, the amount of
time and effort it takes to get them done is often more than if we'd
just sat down and worked them out by hand. This is because computers
(and Julia in particular) are not very well suited to doing a single
complicated calculation, as the instructions we'd have to give it would
be as long as the calculation itself. What they're much better at is
anything that boils down to doing the same simple thing repeatedly,
which we can express in much shorter terms.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, colframe=quarto-callout-note-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

This is an example of \emph{Kolmogorov complexity}, which defines the
complexity of an algorithm as the length of the shortest possible
program that could implement it. In general, we'd consider shorter to be
better, as it should take us less time to program.

\end{tcolorbox}

This may sound quite limiting, but in fact it isn't really, in fact it
often serves as more of a benefit for streamlining some or all of the
problem we're trying to solve rather than a detriment where such
repetition is infeasible. We've already met some of the tools needed to
achieve this, namely loops from Chapter~\ref{sec-controlflow} and custom
functions from Chapter~\ref{sec-customstructures}. We'll now look at how
we can store this data, into several different types that we'll term
\emph{collections}, and some tricks to operating on our data that are
better optimised than the loops and functions that we may write. In
particular, we'll look at some of the subtypes of
\texttt{AbstractArray}, all of which perform this purpose.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Useful for convenient broadcasting in the arrange function}
\ImportTok{import} \BuiltInTok{Base.+}
\FunctionTok{+}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Any}\NormalTok{,}\OperatorTok{::}\DataTypeTok{Nothing}\NormalTok{) }\OperatorTok{=}\NormalTok{ x}

\CommentTok{\# Arranges the subtype tree of T with positions of each of the subtypes}
\CommentTok{\# Format of output is a vector of tuples of the form:}
\CommentTok{\#     (type, number of nodes below, depth, position from top)}
\KeywordTok{function} \FunctionTok{arrange}\NormalTok{(T}\OperatorTok{::}\DataTypeTok{Type}\NormalTok{)}

    \CommentTok{\# Deals with small cases, where a type is not defined in Base we ignore it}
    \FunctionTok{isdefined}\NormalTok{(}\BuiltInTok{Base}\NormalTok{, }\FunctionTok{Symbol}\NormalTok{(T)) }\OperatorTok{||} \ControlFlowTok{return} \DataTypeTok{Tuple}\NormalTok{\{}\DataTypeTok{Type}\NormalTok{, }\DataTypeTok{Int64}\NormalTok{, }\DataTypeTok{Int64}\NormalTok{, }\DataTypeTok{Rational}\NormalTok{\{}\DataTypeTok{Int64}\NormalTok{\}\}[]}
    \FunctionTok{isabstracttype}\NormalTok{(T) }\OperatorTok{||} \ControlFlowTok{return}\NormalTok{ [(T, }\FloatTok{1}\NormalTok{, }\FloatTok{1}\NormalTok{, }\FloatTok{1}\OperatorTok{//}\FloatTok{1}\NormalTok{)]}

\NormalTok{    subT }\OperatorTok{=} \FunctionTok{subtypes}\NormalTok{(T)}
    
\NormalTok{    typelist }\OperatorTok{=} \DataTypeTok{Tuple}\NormalTok{\{}\DataTypeTok{Type}\NormalTok{, }\DataTypeTok{Int64}\NormalTok{, }\DataTypeTok{Int64}\NormalTok{, }\DataTypeTok{Rational}\NormalTok{\{}\DataTypeTok{Int64}\NormalTok{\}\}[]}
\NormalTok{    offset }\OperatorTok{=} \FloatTok{0}
    \ControlFlowTok{for}\NormalTok{ S }\OperatorTok{∈}\NormalTok{ subT}
        
        \CommentTok{\# Prevents an infinite loop}
\NormalTok{        S }\OperatorTok{==} \DataTypeTok{Any} \OperatorTok{\&\&} \ControlFlowTok{continue}
        \CommentTok{\# Recursively gets the arrangement of each subtype}
\NormalTok{        Stypelist }\OperatorTok{=} \FunctionTok{arrange}\NormalTok{(S)}

        \CommentTok{\# Alters the arrangement to fit with the new graph}
        \FunctionTok{append!}\NormalTok{(typelist,}
\NormalTok{            [st }\OperatorTok{.+}\NormalTok{ (}\ConstantTok{nothing}\NormalTok{, }\ConstantTok{nothing}\NormalTok{, }\FloatTok{1}\NormalTok{, offset) for st }\OperatorTok{∈}\NormalTok{ Stypelist]}
\NormalTok{        )}
        \CommentTok{\# Recalculates the offset to accommodate for the new points added}
        \FunctionTok{isempty}\NormalTok{(Stypelist) }\OperatorTok{||}\NormalTok{ (offset }\OperatorTok{+=}\NormalTok{ (Stypelist[}\KeywordTok{end}\NormalTok{])[}\FloatTok{2}\NormalTok{] }\OperatorTok{+} \FloatTok{1}\NormalTok{)}
        
    \ControlFlowTok{end}
    \CommentTok{\# Adds the tuple for T itself to the end of the vector, and returns}
    \FunctionTok{push!}\NormalTok{(typelist, (T, offset, }\FloatTok{1}\NormalTok{, offset}\OperatorTok{//}\FloatTok{2}\NormalTok{))}
    
\KeywordTok{end}

\ImportTok{using} \BuiltInTok{Plots}
\CommentTok{\# Plots the type tree for the subtypes of T}
\KeywordTok{function} \FunctionTok{typetree}\NormalTok{(T}\OperatorTok{::}\DataTypeTok{Type}\NormalTok{)}

\NormalTok{    typelist }\OperatorTok{=} \FunctionTok{arrange}\NormalTok{(T)}

\NormalTok{    types}\OperatorTok{::}\DataTypeTok{Vector\{Type\}                 }\OperatorTok{=}\NormalTok{ [st[}\FloatTok{1}\NormalTok{] for st }\OperatorTok{∈}\NormalTok{ typelist]}
\NormalTok{    spans}\OperatorTok{::}\DataTypeTok{Vector\{Int64\}                }\OperatorTok{=}\NormalTok{ [st[}\FloatTok{2}\NormalTok{] for st }\OperatorTok{∈}\NormalTok{ typelist]}
\NormalTok{    depths}\OperatorTok{::}\DataTypeTok{Vector\{Int64\}               }\OperatorTok{=}\NormalTok{ [st[}\FloatTok{3}\NormalTok{] for st }\OperatorTok{∈}\NormalTok{ typelist]}
\NormalTok{    vpositions}\OperatorTok{::}\DataTypeTok{Vector\{Rational\{Int64\}\} }\OperatorTok{=}\NormalTok{ [st[}\FloatTok{4}\NormalTok{] for st }\OperatorTok{∈}\NormalTok{ typelist]}
\NormalTok{    n }\OperatorTok{=} \FunctionTok{length}\NormalTok{(typelist)}

\NormalTok{    xgap }\OperatorTok{=} \FloatTok{750} \OperatorTok{÷} \FunctionTok{max}\NormalTok{(depths}\OperatorTok{...}\NormalTok{)}
\NormalTok{    ygap }\OperatorTok{=} \FloatTok{750} \OperatorTok{÷}\NormalTok{ spans[}\KeywordTok{end}\NormalTok{]}

    \FunctionTok{plot}\NormalTok{(}
\NormalTok{        size }\OperatorTok{=}\NormalTok{ (}\FloatTok{750}\NormalTok{, }\FloatTok{750}\NormalTok{),}
\NormalTok{        grid }\OperatorTok{=} \ConstantTok{false}\NormalTok{,}
\NormalTok{        showaxis }\OperatorTok{=} \ConstantTok{false}\NormalTok{,}
\NormalTok{        legend }\OperatorTok{=} \ConstantTok{false}\NormalTok{,}
\NormalTok{        xlims }\OperatorTok{=}\NormalTok{ (xgap }\OperatorTok{{-}} \FloatTok{50}\NormalTok{, }\FloatTok{750} \OperatorTok{+} \FloatTok{50}\NormalTok{),}
\NormalTok{        ylims }\OperatorTok{=}\NormalTok{ (ygap }\OperatorTok{{-}} \FloatTok{20}\NormalTok{, }\FloatTok{750} \OperatorTok{+} \FloatTok{20}\NormalTok{)}
\NormalTok{    )}

    \CommentTok{\# Abstract types in grey, concrete types in black}
    \FunctionTok{plot!}\NormalTok{(}
\NormalTok{        annotations }\OperatorTok{=}\NormalTok{ [}
\NormalTok{            (depths[i] }\OperatorTok{*}\NormalTok{ xgap, vpositions[i] }\OperatorTok{*}\NormalTok{ ygap,}
\NormalTok{            (types[i], }\FloatTok{10}\NormalTok{, }\FunctionTok{isabstracttype}\NormalTok{(types[i]) ? }\OperatorTok{:}\NormalTok{grey }\OperatorTok{:} \OperatorTok{:}\NormalTok{black), }\StringTok{"sans{-}serif"}\NormalTok{)}
\NormalTok{            for i }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\NormalTok{n}
\NormalTok{        ]   }
\NormalTok{    )}

\NormalTok{    lines }\OperatorTok{=}\NormalTok{ [}
\NormalTok{        ([(depths[i] }\OperatorTok{+} \FloatTok{1}\OperatorTok{//}\FloatTok{2}\NormalTok{) }\OperatorTok{*}\NormalTok{ xgap, (depths[i] }\OperatorTok{+} \FloatTok{1}\OperatorTok{//}\FloatTok{2}\NormalTok{) }\OperatorTok{*}\NormalTok{ xgap],}
\NormalTok{        [(vpositions[i] }\OperatorTok{{-}}\NormalTok{ spans[i]}\OperatorTok{//}\FloatTok{2}\NormalTok{) }\OperatorTok{*}\NormalTok{ ygap, (vpositions[i] }\OperatorTok{+}\NormalTok{ spans[i]}\OperatorTok{//}\FloatTok{2}\NormalTok{) }\OperatorTok{*}\NormalTok{ ygap])}
\NormalTok{        for i }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\NormalTok{n if }\FunctionTok{isabstracttype}\NormalTok{(types[i])}
\NormalTok{    ]}

    \CommentTok{\# Lines delineate the set of subtypes for each abstract type}
    \FunctionTok{plot!}\NormalTok{(}
\NormalTok{        [}\FunctionTok{Shape}\NormalTok{(line}\OperatorTok{...}\NormalTok{) for line }\OperatorTok{∈}\NormalTok{ lines],}
\NormalTok{        fillcolor }\OperatorTok{=} \OperatorTok{:}\NormalTok{white,}
\NormalTok{        linecolor }\OperatorTok{=} \OperatorTok{:}\NormalTok{lightgrey,}
\NormalTok{        linewidth }\OperatorTok{=} \FloatTok{4}
\NormalTok{    )}
    
\KeywordTok{end}

\FunctionTok{typetree}\NormalTok{(}\DataTypeTok{AbstractArray}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/basics/arrays/arrays_files/figure-pdf/cell-2-output-1.pdf}

}

\end{figure}

We'll also demonstrate our first example of computing something that
would be slow and difficult to do by hand, by looking at Julia sets.

\hypertarget{tuples}{%
\section{\texorpdfstring{\texttt{Tuple}s}{Tuples}}\label{tuples}}

The first type we'll look at doesn't actually appear on this diagram due
to the way it is implemented, although it behaves similarly to many that
do, and this is the \texttt{Tuple}. A \texttt{Tuple} brings several
values together under one variable name, each of which can be
individually retrieved if needed. We do this by separating the values
with commas, and enclosing the whole collection in parentheses:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sthings }\OperatorTok{=}\NormalTok{ (}\StringTok{"sassy"}\NormalTok{, }\FloatTok{6}\NormalTok{, }\FunctionTok{Char}\NormalTok{(}\FloatTok{128013}\NormalTok{), }\FunctionTok{typeof}\NormalTok{(}\StringTok{"s"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
("sassy", 6, '🐍', String)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tthings }\OperatorTok{=}\NormalTok{ (}\StringTok{"tatty"}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FunctionTok{Char}\NormalTok{(}\FloatTok{128047}\NormalTok{), }\FunctionTok{typeof}\NormalTok{(sthings))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
("tatty", 2, '🐯', Tuple{String, Int64, Char, DataType})
\end{verbatim}

We query a particular element of a \texttt{Tuple} by following the
variable name (or indeed a \texttt{Tuple} literal) with square brackets
enclosing the position of the element we want as a number (the
\emph{index} of the element):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\FloatTok{2}\NormalTok{, }\FloatTok{4}\NormalTok{, }\FloatTok{6}\NormalTok{, }\FloatTok{8}\NormalTok{)[}\FloatTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-caution-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-caution-color}{\faFire}\hspace{0.5em}{Caution}, colframe=quarto-callout-caution-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

In many programming languages, tuples or similar structures are indexed
starting at \texttt{0} (so the equivalent of \texttt{x{[}0{]}} would
return the first element of \texttt{x}). Julia takes the other approach,
and starts indexing from \texttt{1} (so \texttt{x{[}1{]}} gives the
first element), which tends to be more natural for beginners anyway.

\end{tcolorbox}

Multiple elements can be returned at once, by indexing with some of the
types we'll meet later, such as using the \texttt{Vector} of
\texttt{Int64}s \texttt{{[}1,\ 4{]}} to get the first and fourth
elements, or the \texttt{UnitRange} \texttt{1:4} to get the first four
elements.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sthings[[}\FloatTok{2}\NormalTok{,}\FloatTok{4}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(6, String)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tthings[}\FloatTok{1}\OperatorTok{:}\FloatTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
("tatty", 2, '🐯')
\end{verbatim}

The index \texttt{:} returns all elements, while \texttt{end} returns
the last one (and \texttt{end-1} the second last, etc.).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sthings[}\OperatorTok{:}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
("sassy", 6, '🐍', String)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tthings[}\KeywordTok{end}\OperatorTok{{-}}\FloatTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
\end{verbatim}

Also, there are functions that will return elements of a \texttt{Tuple},
such as \texttt{first} and \texttt{last}, which do exactly as you'd
expect:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{first}\NormalTok{(sthings)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"sassy"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{last}\NormalTok{(sthings)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
String
\end{verbatim}

The function \texttt{length} gives the number of elements in a
\texttt{Tuple}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(sthings)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4
\end{verbatim}

Additionally, we can search through a \texttt{Tuple} with functions like
\texttt{findall}, \texttt{findmin}, \texttt{findnext}. We'll demonstrate
\texttt{findall}, which applys a function to each element of the
\texttt{Tuple}, and returns a \texttt{Vector} of indices where the
function returns \texttt{true}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{findall}\NormalTok{(x }\OperatorTok{{-}\textgreater{}}\NormalTok{ x isa }\DataTypeTok{String}\NormalTok{, tthings)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1-element Vector{Int64}:
 1
\end{verbatim}

If the elements all have the same type, other function may be used. For
example, a \texttt{Tuple} consisting solely of \texttt{Bool}s can be
used with the functions \texttt{any} and \texttt{all}, which act much
like \texttt{\textbar{}\textbar{}} and \texttt{\&\&} respectively:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{any}\NormalTok{((}\FloatTok{4}\NormalTok{ isa }\DataTypeTok{Integer}\NormalTok{, }\StringTok{"4"}\NormalTok{ isa }\DataTypeTok{Integer}\NormalTok{, }\OperatorTok{:}\NormalTok{four isa }\DataTypeTok{Integer}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{all}\NormalTok{((}\FloatTok{4}\NormalTok{ isa }\DataTypeTok{Integer}\NormalTok{, }\StringTok{"4"}\NormalTok{ isa }\DataTypeTok{Integer}\NormalTok{, }\OperatorTok{:}\NormalTok{four isa }\DataTypeTok{Integer}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
false
\end{verbatim}

Many other such functions exist, and all of these functions, as well as
the means of indexing, will work on any other ordered collection such as
those we describe below.

\hypertarget{arrays}{%
\section{\texorpdfstring{\texttt{Array}s}{Arrays}}\label{arrays}}

An \texttt{Array} is a collection of many values of a given type (or
subtypes thereof). These can be arranged all in a line (like a
\texttt{Tuple}), or indexed in multiple dimensions, such as a
two-dimensional table, or a three-dimensional set of coordinates in 3D
space. \texttt{Array} is a parametric type, with parameters of the type
of the elements, and the number of dimensions. For example, an
\texttt{Array} could exist with type \texttt{Array\{Int64,\ 2\}}, which
would mean that it consists of \texttt{Int64}s arranged in two
dimensions.

Two ``types'' that don't appear in the diagram above are \texttt{Vector}
and \texttt{Matrix}, which are actually just aliases for varieties of
\texttt{Array}: \texttt{Vector\{T\}} is a one-dimensional \texttt{Array}
of type \texttt{T}, and \texttt{Matrix\{T\}} is a two-dimensional
\texttt{Array} of type \texttt{T}. Most \texttt{Array}s that we define
will end up being one of these, unless more dimensions are specifically
necessary.

\hypertarget{defining-and-indexing-arrays}{%
\subsection{\texorpdfstring{Defining and indexing
\texttt{Array}s}{Defining and indexing Arrays}}\label{defining-and-indexing-arrays}}

To define a \texttt{Vector} (i.e.~a one-dimensional \texttt{Array}), we
seperate the elements we want with either commas or semi-colons:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\FloatTok{1}\NormalTok{, }\FloatTok{5}\NormalTok{, }\FloatTok{3}\NormalTok{, }\FloatTok{8}\NormalTok{, }\OperatorTok{{-}}\FloatTok{6}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5-element Vector{Int64}:
  1
  5
  3
  8
 -6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{countries }\OperatorTok{=}\NormalTok{ [}\StringTok{"India"}\NormalTok{; }\StringTok{"Sweden"}\NormalTok{; }\StringTok{"Brazil"}\NormalTok{; }\StringTok{"Ghana"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4-element Vector{String}:
 "India"
 "Sweden"
 "Brazil"
 "Ghana"
\end{verbatim}

The type of a \texttt{Vector} can be specified by preceding the square
brackets with the type name. This can construct \texttt{Vector}s with
zero length, such as:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v }\OperatorTok{=} \DataTypeTok{Int64}\NormalTok{[]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Int64[]
\end{verbatim}

\texttt{Vector}s can be indexed just like \texttt{Tuple}s, but using the
same syntax, we can also change a particular element, treating it as we
would a variable:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers[}\FloatTok{5}\NormalTok{] }\OperatorTok{=} \FloatTok{6}
\NormalTok{numbers}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5-element Vector{Int64}:
 1
 5
 3
 8
 6
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, colframe=quarto-callout-note-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

The reason that we can do this is that, unlike \texttt{Tuple}s,
\texttt{Array}s are \emph{mutable}, allowing part of the data to be
changed without having to rewrite the whole lot. For reasons of
efficiency, this is not true for most types in Julia. Mutable types have
some other different behaviour from normal immutable types, but we won't
discuss it here.

\end{tcolorbox}

To define a \texttt{Matrix}, we can write its columns out as we would
\texttt{Vector}s, and then concatenate them horizontally with spaces
inside a new set of square brackets:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{morenumbers }\OperatorTok{=}\NormalTok{ [[}\FloatTok{1}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{] [}\OperatorTok{{-}}\FloatTok{1}\NormalTok{, }\OperatorTok{{-}}\FloatTok{2}\NormalTok{, }\OperatorTok{{-}}\FloatTok{3}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3×2 Matrix{Int64}:
 1  -1
 2  -2
 3  -3
\end{verbatim}

Alternatively, we can use double semi-colons to mark a new column:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{morecountries }\OperatorTok{=}\NormalTok{ [}\StringTok{"Peru"}\NormalTok{; }\StringTok{"Colombia"}\NormalTok{;; }\StringTok{"Egypt"}\NormalTok{; }\StringTok{"Zambia"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2×2 Matrix{String}:
 "Peru"      "Egypt"
 "Colombia"  "Zambia"
\end{verbatim}

Finally, we may use a combination of spaces and line breaks to construct
a matrix, with spaces separating elements in the same row, and line
breaks separating rows from each other:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{I }\OperatorTok{=}\NormalTok{ [ }\FloatTok{1} \FloatTok{0} \FloatTok{0} 
      \FloatTok{0} \FloatTok{1} \FloatTok{0} 
      \FloatTok{0} \FloatTok{0} \FloatTok{1}\NormalTok{ ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3×3 Matrix{Int64}:
 1  0  0
 0  1  0
 0  0  1
\end{verbatim}

To index elements of a \texttt{Matrix}, we use two numbers, the first
for the row number, the second for the column number, separated by a
comma:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{morecountries[}\FloatTok{2}\NormalTok{,}\FloatTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"Colombia"
\end{verbatim}

It is also possible to use single numbers as indices for a
\texttt{Matrix}, the order being to go down the columns first (so-called
\emph{column-major} ordering). This can be seen through the
\texttt{LinearIndices} type, which gives each the numerical index of
each element of the \texttt{Matrix} used in its construction:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{LinearIndices}\NormalTok{(I)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3×3 LinearIndices{2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}:
 1  4  7
 2  5  8
 3  6  9
\end{verbatim}

Similar principles apply to higher dimensions, in particular the use of
semi-colons to denote dimension number to concatenate along, and the
means of indexing the elements.

An \texttt{Array} specific relative of \texttt{length} is the
\texttt{size} function, which returns a \texttt{Tuple} of the number of
elements along each dimension of the \texttt{Array} (column-major
ordering meaning that the number of elements in each column comes
first):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{size}\NormalTok{(morenumbers)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(3, 2)
\end{verbatim}

\hypertarget{construction-of-arrays-by-functions}{%
\subsection{Construction of arrays by
functions}\label{construction-of-arrays-by-functions}}

Another way we can construct an \texttt{Array} is by the use of a
function which returns an \texttt{Array}. To get a \texttt{Vector} of
type \texttt{T} and length \texttt{n}, we can use the
\texttt{Vector\{T\}} constructor, with arguments \texttt{undef} (which
initialises an \texttt{Array} with arbitrary values that we can replace
later) and the desired length \texttt{n}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Vector}\DataTypeTok{\{String\}}\NormalTok{(}\ConstantTok{undef}\NormalTok{, }\FloatTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3-element Vector{String}:
 #undef
 #undef
 #undef
\end{verbatim}

We can do the same with a \texttt{Matrix}, specifying two dimensions, or
a general \texttt{Array}, specifying as many dimensions as we need:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Matrix}\DataTypeTok{\{ComplexF64\}}\NormalTok{(}\ConstantTok{undef}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2×4 Matrix{ComplexF64}:
 1.02183e-311+1.02183e-311im  …  0.0+0.0im  0.0+0.0im
 1.02183e-311+1.02183e-311im     0.0+0.0im  0.0+0.0im
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Array}\DataTypeTok{\{Bool\}}\NormalTok{(}\ConstantTok{undef}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2×2×2 Array{Bool, 3}:
[:, :, 1] =
 0  1
 1  0

[:, :, 2] =
 1  0
 1  0
\end{verbatim}

We can also initialise \texttt{Array}s with specified values, with
functions such as \texttt{fill}, \texttt{zeros}, \texttt{ones}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{fill}\NormalTok{(}\StringTok{"ostrich"}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2×2 Matrix{String}:
 "ostrich"  "ostrich"
 "ostrich"  "ostrich"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Rational}\NormalTok{\{}\DataTypeTok{Int64}\NormalTok{\}, }\FloatTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3-element Vector{Rational{Int64}}:
 0//1
 0//1
 0//1
\end{verbatim}

The \texttt{rand} function fills an \texttt{Array} of the given
dimensions with (as best it can) uniformly random \texttt{Float64}s
between \texttt{0} and \texttt{1}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rand}\NormalTok{(}\FloatTok{4}\NormalTok{,}\FloatTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4×3 Matrix{Float64}:
 0.108065  0.868455  0.995519
 0.165468  0.078252  0.0696596
 0.753003  0.62981   0.065973
 0.655447  0.258828  0.325023
\end{verbatim}

It can also randomly choose from a collection:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rand}\NormalTok{(}\FloatTok{1}\OperatorTok{:}\FloatTok{100}\NormalTok{, }\FloatTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6-element Vector{Int64}:
 53
 27
 51
 75
 62
 35
\end{verbatim}

The \texttt{collect} function allows an \texttt{Array} to be created
with the values of another sort of collection. We can see this
demonstrated with a \texttt{UnitRange} and a \texttt{String}, which we
discuss more later:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{collect}\NormalTok{(}\FloatTok{1}\OperatorTok{:}\FloatTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5-element Vector{Int64}:
 1
 2
 3
 4
 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{collect}\NormalTok{(}\StringTok{"mongoose"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
8-element Vector{Char}:
 'm': ASCII/Unicode U+006D (category Ll: Letter, lowercase)
 'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)
 'n': ASCII/Unicode U+006E (category Ll: Letter, lowercase)
 'g': ASCII/Unicode U+0067 (category Ll: Letter, lowercase)
 'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)
 'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)
 's': ASCII/Unicode U+0073 (category Ll: Letter, lowercase)
 'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)
\end{verbatim}

\hypertarget{adding-and-removing-elements-from-a-vector}{%
\subsection{\texorpdfstring{Adding and removing elements from a
\texttt{Vector}}{Adding and removing elements from a Vector}}\label{adding-and-removing-elements-from-a-vector}}

The mutability of \texttt{Vector}s allows another operation that
\texttt{Tuple}s can't do, which is to add onto and take away elements
from \texttt{Vector}s that we've already got. Let's start with an empty
\texttt{Vector\{Int64\}};

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v }\OperatorTok{=} \DataTypeTok{Int64}\NormalTok{[]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Int64[]
\end{verbatim}

The \texttt{append!} function add a given element or elements to the end
of a \texttt{Vector}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{append!}\NormalTok{(v, }\FloatTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1-element Vector{Int64}:
 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{append!}\NormalTok{(v, [}\FloatTok{4}\NormalTok{, }\FloatTok{2}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3-element Vector{Int64}:
 6
 4
 2
\end{verbatim}

The \texttt{prepend!} function does the same at the start:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{prepend!}\NormalTok{(v, }\FloatTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4-element Vector{Int64}:
 3
 6
 4
 2
\end{verbatim}

The functions \texttt{push!} and \texttt{pushfirst!} work similarly to
\texttt{append!} and \texttt{prepend!} respectively. To insert an
element at a specific index, we can use \texttt{insert!}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{insert!}\NormalTok{(v, }\FloatTok{4}\NormalTok{, }\OperatorTok{{-}}\FloatTok{1}\NormalTok{) }\CommentTok{\# First number is the index, second is the value to insert}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5-element Vector{Int64}:
  3
  6
  4
 -1
  2
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Convention}, colframe=quarto-callout-tip-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Functions on mutable inputs which mutate one of the inputs (usually the
first) are named with an \texttt{!} at the end. For example, the
functions above mutate the input \texttt{v}, changing the value of the
variable and not just calculating an output.

\end{tcolorbox}

To remove elements, we can use \texttt{pop!}. This gets returns the last
element of the \texttt{Vector}, but also gets rid of it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pop!}\NormalTok{(v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4-element Vector{Int64}:
  3
  6
  4
 -1
\end{verbatim}

Other elements can be removed by \texttt{popfirst!} and \texttt{popat!}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{popat!}\NormalTok{(v, }\FloatTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3-element Vector{Int64}:
  3
  6
 -1
\end{verbatim}

The function \texttt{splice!} combines \texttt{popat!} and
\texttt{insert!}, allowing us to remove an element and replace it with
one or more new ones at the same time:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{splice!}\NormalTok{(v, }\FloatTok{2}\NormalTok{, [}\FloatTok{2}\NormalTok{, }\FloatTok{1}\NormalTok{, }\FloatTok{0}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5-element Vector{Int64}:
  3
  2
  1
  0
 -1
\end{verbatim}

For higher dimensional \texttt{Array}s, such as a \texttt{Matrix}, this
is not as simple (for example you can't just remove the last element).
In general, for reasons of cleanness of code and efficiency,
\texttt{Array}s should be initialised as the size that they need to be
to begin with, having their values filled in later, but sometimes you
won't be able to do this, in which case the mutating functions are your
best option.

\hypertarget{array-comprehension}{%
\subsection{Array comprehension}\label{array-comprehension}}

There's a third way of filling \texttt{Array}s with even more control
over the initial values, which is \emph{array comprehension}. This acts
much like a \texttt{for} loop, indeed it uses much of the same syntax,
filling an \texttt{Array} with some function of the elements in a
collection. Instead of writing the elements of the \texttt{Array}
between the square brackets, we write a rule for generating them:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[i}\OperatorTok{\^{}}\FloatTok{2}\NormalTok{ for i }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\FloatTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
10-element Vector{Int64}:
   1
   4
   9
  16
  25
  36
  49
  64
  81
 100
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\FunctionTok{first}\NormalTok{(c) for c }\OperatorTok{∈}\NormalTok{ countries]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4-element Vector{Char}:
 'I': ASCII/Unicode U+0049 (category Lu: Letter, uppercase)
 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)
 'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)
 'G': ASCII/Unicode U+0047 (category Lu: Letter, uppercase)
\end{verbatim}

These give \texttt{Vector}s, as the \texttt{for} loop iterates over
one-dimensional collections. We can get a two-dimensional
\texttt{Matrix} either by iterating over two one-dimensional
collections:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[i}\OperatorTok{*}\NormalTok{j for i }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\FloatTok{10}\NormalTok{, j }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\FloatTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
10×10 Matrix{Int64}:
  1   2   3   4   5   6   7   8   9   10
  2   4   6   8  10  12  14  16  18   20
  3   6   9  12  15  18  21  24  27   30
  4   8  12  16  20  24  28  32  36   40
  5  10  15  20  25  30  35  40  45   50
  6  12  18  24  30  36  42  48  54   60
  7  14  21  28  35  42  49  56  63   70
  8  16  24  32  40  48  56  64  72   80
  9  18  27  36  45  54  63  72  81   90
 10  20  30  40  50  60  70  80  90  100
\end{verbatim}

or by iterating over one two-dimensional collection, such as another
matrix:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\FunctionTok{first}\NormalTok{(c) for c }\OperatorTok{∈}\NormalTok{ morecountries]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2×2 Matrix{Char}:
 'P'  'E'
 'C'  'Z'
\end{verbatim}

Following this with \texttt{if} inside the square brackets allows us to
skip elements which don't meet a condition:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[i for i }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\FloatTok{10}\NormalTok{ if }\FunctionTok{iseven}\NormalTok{(i) }\OperatorTok{\&\&}\NormalTok{ i }\OperatorTok{\textless{}} \FloatTok{7}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3-element Vector{Int64}:
 2
 4
 6
\end{verbatim}

\hypertarget{other-ordered-collection-types}{%
\section{Other ordered collection
types}\label{other-ordered-collection-types}}

\hypertarget{ranges}{%
\subsection{Ranges}\label{ranges}}

We've already met a type of range in Chapter~\ref{sec-controlflow},
which used the syntax \texttt{1:10} to represent the numbers from
\texttt{1} to \texttt{10} (or similar). This notation extends further:

\begin{itemize}
\tightlist
\item
  \texttt{a:b} means the numbers \texttt{a}, \texttt{a+1}, \texttt{a+2},
  continuing to add \texttt{1} until we would exceed \texttt{b} by
  adding \texttt{1} more
\item
  \texttt{a:d:b} means the same, but the gap between successive numbers
  is now \texttt{d} instead of \texttt{1}
\end{itemize}

It is also possible to specify ranges using the \texttt{range} function,
which allows four keyword parameters to be set, \texttt{start},
\texttt{stop}, \texttt{step}, and \texttt{length}. Only three of these
are necessary (indeed you get an error if you try to specify all four),
and they allow for options of evenly spaced ranges, including using
\texttt{Complex} numbers:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{range}\NormalTok{(start }\OperatorTok{=} \FloatTok{1}\NormalTok{, step }\OperatorTok{=} \FloatTok{1im}\NormalTok{, length }\OperatorTok{=} \FloatTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1 + 0im:0 + 1im:1 + 4im
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-warning-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Warning}, colframe=quarto-callout-warning-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Despite how this is displayed, \texttt{1\ +\ 0im:0\ +\ 1im:1\ +\ 4im}
will not work if you try to type it out, because it tries to call
\texttt{range} with the \texttt{start}, \texttt{stop}, and \texttt{step}
keywords. For \texttt{Complex} values, where a notion of
\texttt{\textless{}} doesn't exist, having a stopping point is difficult
to work with, so \texttt{length} should be specified instead of
\texttt{stop}.

\end{tcolorbox}

The exact type of the range returned depends on the values you start
with, but any parametric subtypes of \texttt{UnitRange},
\texttt{StepRange}, or \texttt{StepRangeLen} are possible.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\FloatTok{1}\OperatorTok{:}\FloatTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
UnitRange{Int64}
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\FloatTok{1}\OperatorTok{:}\FloatTok{2}\OperatorTok{:}\FloatTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
StepRange{Int64, Int64}
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\FunctionTok{range}\NormalTok{(start }\OperatorTok{=} \FloatTok{1}\NormalTok{, step }\OperatorTok{=} \FloatTok{1im}\NormalTok{, length }\OperatorTok{=} \FloatTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
StepRangeLen{Complex{Int64}, Int64, Complex{Int64}, Int64}
\end{verbatim}

The remaining subtype of \texttt{AbstractRange} is \texttt{LinRange},
which is a performance optimised but error prone alternative to
specifying a range with \texttt{start}, \texttt{stop}, and
\texttt{length}.

\hypertarget{cartesianindices}{%
\subsection{\texorpdfstring{\texttt{CartesianIndices}}{CartesianIndices}}\label{cartesianindices}}

A \texttt{CartesianIndex} is a type that acts much like a
\texttt{Tuple}, but is specifically meant as an index for an
\texttt{Array}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ci }\OperatorTok{=} \FunctionTok{CartesianIndex}\NormalTok{(}\FloatTok{1}\NormalTok{,}\FloatTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
CartesianIndex(1, 2)
\end{verbatim}

Indeed, we can use a \texttt{CartesianIndex} as an index:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A }\OperatorTok{=}\NormalTok{ [ }\FloatTok{1} \FloatTok{3}
      \FloatTok{2} \FloatTok{4}\NormalTok{ ]}

\NormalTok{A[ci]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A[}\FloatTok{1}\NormalTok{,}\FloatTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

Despite being \texttt{Tuple}-like, \texttt{CartesianIndex} is not
considered a collection of items (there's a specific error if you try to
index one of them). However, a collection of all possible
\texttt{CartesianIndex} indices of an \texttt{Array} does exist as its
own type, \texttt{CartesianIndices}, which is a subtype of
\texttt{AbstractArray}, and so does have the expected indexing
behaviour. We can either give it an \texttt{Array}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{indicesA }\OperatorTok{=} \FunctionTok{CartesianIndices}\NormalTok{(A)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
CartesianIndices((2, 2))
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{collect}\NormalTok{(indicesA)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2×2 Matrix{CartesianIndex{2}}:
 CartesianIndex(1, 1)  CartesianIndex(1, 2)
 CartesianIndex(2, 1)  CartesianIndex(2, 2)
\end{verbatim}

or a \texttt{Tuple} of ranges, to form the grid of possible indices:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rangeindices }\OperatorTok{=} \FunctionTok{CartesianIndices}\NormalTok{((}\FloatTok{1}\OperatorTok{:}\FloatTok{2}\OperatorTok{:}\FloatTok{5}\NormalTok{, }\FloatTok{3}\OperatorTok{:{-}}\FloatTok{1}\OperatorTok{:}\FloatTok{0}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
CartesianIndices((1:2:5, 3:-1:0))
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{collect}\NormalTok{(rangeindices)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3×4 Matrix{CartesianIndex{2}}:
 CartesianIndex(1, 3)  CartesianIndex(1, 2)  …  CartesianIndex(1, 0)
 CartesianIndex(3, 3)  CartesianIndex(3, 2)     CartesianIndex(3, 0)
 CartesianIndex(5, 3)  CartesianIndex(5, 2)     CartesianIndex(5, 0)
\end{verbatim}

\hypertarget{strings}{%
\subsection{\texorpdfstring{\texttt{String}s}{Strings}}\label{strings}}

Strings are again not a subtype of \texttt{AbstractArray}, and for good
reason, they perform a wildly different function most of the time (see
Chapter~\ref{sec-strings}), and don't work the same with functions as
the other types here do. However, it is worth mentioning them, as they
exhibit similar indexing properties as we've seen before, and in this
way can sometimes behave as if they were a \texttt{Tuple} consisting of
\texttt{Char}s:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"daffodil"}\NormalTok{[}\FloatTok{3}\OperatorTok{:}\FloatTok{4}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"ff"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(}\StringTok{"daffodil"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
8
\end{verbatim}

\hypertarget{unordered-collection-types}{%
\section{Unordered collection types}\label{unordered-collection-types}}

All of the above types we've encountered are ordered, in the sense that
it's meaningful to ask what the first element is, what the second is,
etc. However, sometimes we don't even need this information, and Julia
provides types that ignore this for the sake of efficiency.

\hypertarget{set}{%
\subsection{\texorpdfstring{\texttt{Set}}{Set}}\label{set}}

A set is a collection of values, much like a \texttt{Vector} or a
\texttt{Tuple}, but without an order, and without duplicates. We can
construct a set by giving our collection of values in one of the other
formats we've seen above:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbersset }\OperatorTok{=} \FunctionTok{Set}\NormalTok{(}\FloatTok{1}\OperatorTok{:}\FloatTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Set{Int64} with 6 elements:
  5
  4
  6
  2
  3
  1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{magicset }\OperatorTok{=} \FunctionTok{Set}\NormalTok{(}\StringTok{"abracadabra"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Set{Char} with 5 elements:
  'a'
  'c'
  'd'
  'r'
  'b'
\end{verbatim}

Although these have an order of sorts when displayed, this is merely for
the purpose of displaying them, and indexing doesn't work.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbersset[}\FloatTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: MethodError: no method matching getindex(::Set{Int64}, ::Int64)
\end{verbatim}

This doesn't make them useless, however. Instead, they serve a different
purpose, being optimised for searching and set operations. Searching can
be done with the \texttt{in} function, returning \texttt{true} or
\texttt{false} depending on whether the queried value is found in the
\texttt{Set}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{in}\NormalTok{(}\FloatTok{2}\NormalTok{, numbersset)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

The \texttt{in} function can also be written inline, or replaced by its
alias \texttt{∈} (written by tab-completing
\texttt{\textbackslash{}in}):

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{7} \KeywordTok{in}\NormalTok{ numbersset}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
false
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CharTok{\textquotesingle{}b\textquotesingle{}} \OperatorTok{∈}\NormalTok{ magicset}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

Set operations are also defined, such as \texttt{union}/\texttt{∪}
(\texttt{A\ ∪\ B} is the \texttt{Set} containing all elements that
appear in \texttt{A} or \texttt{B}, or both),
\texttt{intersect}/\texttt{∩} (\texttt{A\ ∩\ B} is the \texttt{Set}
containing all elements that appear in \texttt{A} and in \texttt{B}),
and \texttt{setdiff} (\texttt{setdiff(A,B)} is the \texttt{Set}
containing all elements of \texttt{A} that don't appear in \texttt{B}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbersset }\OperatorTok{∪} \FunctionTok{Set}\NormalTok{([}\FloatTok{10}\NormalTok{, }\FloatTok{11}\NormalTok{, }\FloatTok{12}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Set{Int64} with 9 elements:
  5
  4
  6
  2
  11
  10
  12
  3
  1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{magicset }\OperatorTok{∩} \FunctionTok{Set}\NormalTok{(}\StringTok{"abcdef"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Set{Char} with 4 elements:
  'a'
  'c'
  'd'
  'b'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{setdiff}\NormalTok{(magicset, }\StringTok{"abcdef"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Set{Char} with 1 element:
  'r'
\end{verbatim}

These functions also work for ordered collections such as
\texttt{Tuple}s or \texttt{Vector}s, but on larger scales are quicker
with \texttt{Set}s.

\hypertarget{dict}{%
\subsection{\texorpdfstring{\texttt{Dict}}{Dict}}\label{dict}}

A \texttt{Dict} (short for dictionary) is a little like a \texttt{Tuple}
or a \texttt{Vector}, but the indices can be whatever we choose. This
again means that there isn't necessarily any order to a \texttt{Dict},
since there isn't necessarily an obvious order to the indices. There are
several ways to initialise a \texttt{Dict}, but we'll start with an
empty one, \texttt{Dict()}. Before we run this, we may wish to choose
the types that will be used for the \emph{keys} (that is, the indices),
and the \emph{values} (the data which we store for each key). These go
in curly brackets like a parametric type (indeed, that's what they
are!), for example below, we have chosen \texttt{Char}s as keys, and
\texttt{Int64}s as values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{frequencies }\OperatorTok{=} \FunctionTok{Dict}\DataTypeTok{\{Char, Int64\}}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Dict{Char, Int64}()
\end{verbatim}

Alternatively, we can give a list of initial values, as a
\texttt{Vector} of \texttt{Tuple}s, with each tuple containing a key
followed by the desired value:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{capitals }\OperatorTok{=} \FunctionTok{Dict}\NormalTok{([(}\StringTok{"France"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{), (}\StringTok{"Nigeria"}\NormalTok{, }\StringTok{"Abuja"}\NormalTok{), (}\StringTok{"Chile"}\NormalTok{, }\StringTok{"Santiago"}\NormalTok{)])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Dict{String, String} with 3 entries:
  "Nigeria" => "Abuja"
  "Chile"   => "Santiago"
  "France"  => "Paris"
\end{verbatim}

Finally, we can do the same with a sequence of \texttt{Pair}s.
\texttt{Pair} is a type storing exactly two values, written with
\texttt{=\textgreater{}} between them, and they can be used to construct
a \texttt{Dict} by putting them as inputs into the \texttt{Dict}
constructor, each following the format
\texttt{key\ =\textgreater{}\ value}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{shades }\OperatorTok{=} \FunctionTok{Dict}\NormalTok{(}
    \StringTok{"red"} \OperatorTok{=\textgreater{}}\NormalTok{ [}\StringTok{"scarlet"}\NormalTok{, }\StringTok{"blood"}\NormalTok{, }\StringTok{"ruby"}\NormalTok{],}
    \StringTok{"green"} \OperatorTok{=\textgreater{}}\NormalTok{ [}\StringTok{"lime"}\NormalTok{, }\StringTok{"forest"}\NormalTok{, }\StringTok{"british racing"}\NormalTok{],}
    \StringTok{"blue"} \OperatorTok{=\textgreater{}}\NormalTok{ [}\StringTok{"sky"}\NormalTok{, }\StringTok{"ocean"}\NormalTok{, }\StringTok{"navy"}\NormalTok{]}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Dict{String, Vector{String}} with 3 entries:
  "blue"  => ["sky", "ocean", "navy"]
  "green" => ["lime", "forest", "british racing"]
  "red"   => ["scarlet", "blood", "ruby"]
\end{verbatim}

To add values to a \texttt{Dict}, we can use the indexing syntax that
we've seen before. If the key doesn't exist, we'll get an error when
trying to query a value, but setting a value works for any key, and will
either add or overwrite that value into the \texttt{Dict}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lipsum }\OperatorTok{=} \StringTok{"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."}

\ControlFlowTok{for}\NormalTok{ c }\OperatorTok{∈}\NormalTok{ lipsum}
\NormalTok{    frequencies[c] }\OperatorTok{=} \FunctionTok{haskey}\NormalTok{(frequencies, c) ? frequencies[c] }\OperatorTok{+} \FloatTok{1} \OperatorTok{:} \FloatTok{1}
\ControlFlowTok{end}

\NormalTok{frequencies}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Dict{Char, Int64} with 28 entries:
  'n' => 24
  'f' => 3
  'd' => 18
  'E' => 1
  'e' => 37
  'o' => 29
  'D' => 1
  'h' => 1
  's' => 18
  'i' => 42
  'r' => 22
  't' => 32
  ',' => 4
  'q' => 5
  ' ' => 68
  'a' => 29
  'c' => 16
  'p' => 11
  'm' => 17
  '.' => 4
  'U' => 1
  'L' => 1
  'g' => 3
  'v' => 3
  'u' => 28
  ⋮   => ⋮
\end{verbatim}

We can list out the keys and the values, although as before, the order
will be meaningless:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{keys}\NormalTok{(capitals)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
KeySet for a Dict{String, String} with 3 entries. Keys:
  "Nigeria"
  "Chile"
  "France"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{values}\NormalTok{(capitals)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ValueIterator for a Dict{String, String} with 3 entries. Values:
  "Abuja"
  "Santiago"
  "Paris"
\end{verbatim}

We can also delete keys (and the values that go with them) with
\texttt{pop!} or \texttt{delete!}. These have the same effect on the
\texttt{Dict}, but produce different outputs, \texttt{pop!} returns the
value corresponding to the deleted key, while \texttt{delete!} returns
the new \texttt{Dict}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pop!}\NormalTok{(shades, }\StringTok{"green"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3-element Vector{String}:
 "lime"
 "forest"
 "british racing"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{delete!}\NormalTok{(shades, }\StringTok{"blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Dict{String, Vector{String}} with 1 entry:
  "red" => ["scarlet", "blood", "ruby"]
\end{verbatim}

\texttt{Dict}s are an efficient way to store values under meaningful
names without having to define a large number of variables. For this
reason, one of their most common usages is as a lookup table, where a
common calculation can be precomputed for the possible values that it
could take, and then its answer looked up instead of doing the
calculation all over again every time. For example, instead of counting
the number of times a particular character appears in the text
\texttt{lipsum}, we can look up the count in \texttt{frequencies}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{frequencies[}\CharTok{\textquotesingle{}s\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
18
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{count}\NormalTok{(}\OperatorTok{==}\NormalTok{(}\CharTok{\textquotesingle{}s\textquotesingle{}}\NormalTok{), lipsum) }\CommentTok{\# ==(\textquotesingle{}s\textquotesingle{}) returns the anonymous function x {-}\textgreater{} x == \textquotesingle{}s\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
18
\end{verbatim}

\hypertarget{interaction-with-functions}{%
\section{Interaction with functions}\label{interaction-with-functions}}

These types are already quite useful in storing data in their own
different ways, but where they really come in handy is using them in
combination with functions. One example of this is that the standard
linear algebra rules for multiplying matrices by scalars, vectors, or
other matrices, work seamlessly with the usual operations like
\texttt{*}, \texttt{/}, \texttt{\^{}}, and the \texttt{Vector} and
\texttt{Matrix} types:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A }\OperatorTok{=}\NormalTok{ [ }\FloatTok{2} \FloatTok{3} 
      \FloatTok{5} \FloatTok{1}\NormalTok{ ]}

\FloatTok{2}\NormalTok{A}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2×2 Matrix{Int64}:
  4  6
 10  2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\OperatorTok{{-}}\FloatTok{1}\NormalTok{,}\FloatTok{4}\NormalTok{]}

\NormalTok{A}\OperatorTok{*}\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2-element Vector{Int64}:
 10
 -1
\end{verbatim}

More widely applicable are the \texttt{.}, \texttt{...}, and
\texttt{...} operations (those last two are different!) that allow for
functions to act on collections, and collections to be input into
functions. These are named broadcasting, splatting, and slurping.

\hypertarget{broadcasting}{%
\subsection{Broadcasting}\label{broadcasting}}

When introducing the many different types above, we've seen some
examples of functions which take collections as an input. However, often
we don't want to apply a function to the collection as a whole, instead
we want to apply it to each element individually. This is achieved by
\emph{broadcasting} a function.

The \texttt{broadcast} function provides the first way of doing this.
Its first argument is the function that we want to broadcast, and the
rest of the inputs will serve as the arguments to that function. For
example, compare the following:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A }\OperatorTok{*}\NormalTok{ A}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2×2 Matrix{Int64}:
 19   9
 15  16
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{B }\OperatorTok{=} \FunctionTok{broadcast}\NormalTok{(}\OperatorTok{*}\NormalTok{, A, A) }\CommentTok{\# B[i,j] = A[i,j] * A[i,j]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2×2 Matrix{Int64}:
  4  9
 25  1
\end{verbatim}

Broadcasting will break if the sizes of the inputs don't match. However,
if the sizes do match, but some dimensions are missing, Julia will
smartly account for the missing dimensions and index the inputs
accordingly:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{C }\OperatorTok{=} \FunctionTok{broadcast}\NormalTok{(}\OperatorTok{*}\NormalTok{, A, x) }\CommentTok{\# C[i,j] = A[i,j] * x[i]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2×2 Matrix{Int64}:
 -2  -3
 20   4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{D }\OperatorTok{=} \FunctionTok{broadcast}\NormalTok{(}\OperatorTok{\^{}}\NormalTok{, A, }\FloatTok{2}\NormalTok{) }\CommentTok{\# D[i,j] = A[i,j] \^{} 2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2×2 Matrix{Int64}:
  4  9
 25  1
\end{verbatim}

There are two further ways of broadcasting, with shorter syntax. If a
function has a name (i.e.~isn't anonymous), following its name with a
dot \texttt{.} has the effect of broadcasting:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sinpi}\NormalTok{.(}\FloatTok{0}\OperatorTok{:}\FloatTok{0.2}\OperatorTok{:}\FloatTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
11-element Vector{Float64}:
  0.0
  0.5877852522924731
  0.9510565162951536
  0.9510565162951536
  0.587785252292473
  0.0
 -0.587785252292473
 -0.9510565162951535
 -0.9510565162951535
 -0.587785252292473
  0.0
\end{verbatim}

Most infix operators support a similar syntax, with the \texttt{.}
coming before the operator this time:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A }\OperatorTok{.*}\NormalTok{ A}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2×2 Matrix{Int64}:
  4  9
 25  1
\end{verbatim}

Also, we can start the line with \texttt{@.} (which calls the macro
\texttt{@.}), and this broadcasts all of the functions in that line,
without us having to specify each individually:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{@. }\FunctionTok{sin}\NormalTok{(}\FloatTok{2}\OperatorTok{\^{}}\NormalTok{(}\OperatorTok{{-}}\FloatTok{0.5}\OperatorTok{:}\FloatTok{0.2}\OperatorTok{:}\FloatTok{0.5}\NormalTok{) }\OperatorTok{+} \FloatTok{0.4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6-element Vector{Float64}:
 0.8944084355923738
 0.9364087671697013
 0.9718672058520753
 0.99510124105
 0.9981796067983775
 0.9705200191672874
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Convention}, colframe=quarto-callout-tip-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Note that while array comprehension can achieve the same outcome,
broadcasting tends to be more efficient. For example, the \texttt{@.}
broadcast above could be equally calculated as the following:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\FunctionTok{sin}\NormalTok{(}\FloatTok{2}\OperatorTok{\^{}}\NormalTok{t }\OperatorTok{+} \FloatTok{0.4}\NormalTok{) for t }\OperatorTok{∈} \OperatorTok{{-}}\FloatTok{0.5}\OperatorTok{:}\FloatTok{0.2}\OperatorTok{:}\FloatTok{0.5}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6-element Vector{Float64}:
 0.8944084355923738
 0.9364087671697013
 0.9718672058520753
 0.99510124105
 0.9981796067983775
 0.9705200191672874
\end{verbatim}

but this is noticeably slower for operations on larger collections.

\end{tcolorbox}

\hypertarget{splatting-and-slurping}{%
\subsection{Splatting and slurping}\label{splatting-and-slurping}}

Another way we may want to apply a function to an collection is to have
the elements serve as individual arguments to the same function call. We
do this by \emph{splatting}, effectively emptying the elements in the
order that they are indexed as arguments.

Using the vector \texttt{x\ =\ {[}-1,\ 4{]}} above, we can splat this
into the \texttt{-} function to subtract the second value from the
first.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{{-}}\NormalTok{(x}\OperatorTok{...}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
-5
\end{verbatim}

This isn't particularly useful at the moment, although it could be
situationally handy. Splatting tends to be more useful for certain
functions that take an arbitrary number of inputs, such as \texttt{+}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{+}\NormalTok{(A}\OperatorTok{...}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
11
\end{verbatim}

How do we write a function that has arbitrarily many inputs then? The
answer is the visually identical but conceptually distinct syntax of
\emph{slurping}. If the last argument in the function definition is
followed by \texttt{...}, then it will collect together any further
inputs into the function into a \texttt{Tuple} with that variable name.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{inputcounter}\NormalTok{(args}\OperatorTok{...}\NormalTok{) }\OperatorTok{=} \FunctionTok{length}\NormalTok{(args)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
inputcounter (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{inputcounter}\NormalTok{(}\FloatTok{4}\NormalTok{, }\FloatTok{12}\NormalTok{, }\StringTok{"Friday"}\NormalTok{, }\OperatorTok{:}\NormalTok{cos)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4
\end{verbatim}

We can see how splatting and slurping can work together, first emptying
the values into the function call, and then collecting them back up into
a \texttt{Tuple}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{inputcounter}\NormalTok{(A)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{inputcounter}\NormalTok{(A}\OperatorTok{...}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4
\end{verbatim}

\hypertarget{example-julia-sets}{%
\section{Example: Julia sets}\label{example-julia-sets}}

Since we're working in Julia, it would be remiss not to use it to
generate its namesake mathematical objects: Julia sets (technically
filled Julia sets). These are fractal sets, composed of the points where
iterating some function again and again does not lead you off towards
infinity. They are related to the more famous Mandelbrot set, but their
name happens to be shared with a programming language instead of a type
of biscuit. They will also serve as a useful way to demonstrate some of
the \texttt{Array} operations seen above. Before we start programming,
we'll look at the definition, so we know what to draw.

\hypertarget{mathematical-definition-of-the-julia-set}{%
\subsection{Mathematical definition of the Julia
set}\label{mathematical-definition-of-the-julia-set}}

First, we need a function to iterate. We will use the same functions as
used by the Mandelbrot set, which have one complex parameter \(c\), and
are defined by: \[
F_c(z) = z^2 + c
\]

The (filled) Julia set with parameter \(c\) is then the set of points in
the complex plane where repeated application of \(F_c\) is bounded
(i.e.~the magnitude of the answers doesn't go off to infinity): \[
\mathcal{J}(c) = \left\{ z \in \mathbb{C} : \left| (F_c)^n(z) \right| \not\to \infty \text{ as } n \to \infty \right\}
\]

Here, the power of \(n\) on the function \(F_c\) means applying that
function repeatedly \(n\) times (so \(F_c(F_c(\dots(F_c(z))))\)).

As an example, we'll consider \(\mathcal{J}(0)\). The function \(F_0\)
is simply \(F_0(z) = z^2\), so: \[
(F_0)^n(z) = (((z^2)^2)\dots)^2 = z^{2^n}
\]

Therefore, \(\mathcal{J}(0)\) is the set of points where \(z^{2^n}\) is
bounded as \(n \to \infty\), which is the unit disc, so
\(\mathcal{J}(0) = \{ z \in \mathbb{C} : |z| \leqslant 1 \}\).

To demonstrate how close this is to the Mandelbrot set, here is its
definition: \[
\mathcal{M}(c) = \left\{ c \in \mathbb{C} : \left| (F_c)^n(0) \right| \not\to \infty \text{ as } n \to \infty \right\}
\]

or equivalently: \[
\mathcal{M}(c) = \left\{ c \in \mathbb{C} : 0 \in \mathcal{J}(c) \right\}
\]

\hypertarget{drawing-julia-sets}{%
\subsection{Drawing Julia sets}\label{drawing-julia-sets}}

It's all well and good to have this definition, but as we saw in
Chapter~\ref{sec-numerictypes}, translating mathematics to code is not
straightforward, and in this case, we run into the same issues of having
to represent infinite concepts finitely. In particular, there are two
approximations that we have to make:

\begin{itemize}
\item
  We can't take a limit as \(n \to \infty\) as we would like. Instead,
  we'll set a limit of the number of times we iterate, and assume that
  if \((F_c)^n(z)\) doesn't get too large in that many iterations, it
  never will. If this limit on \(n\) is large enough, this will be a
  decent approximation
\item
  We can't check whether every point in the complex plane is or isn't in
  the Julia set (or even a finite area within it). Instead, we'll choose
  ranges of \(x\) and \(y\) values, which will give us a lattice of
  points \(z = x + yi\) that we can check individually
\end{itemize}

For this purpose, we'll define two parameters to balance accuracy with
speed of computation. \texttt{n} will be the maximum number of
applications of our function before we consider it not to have diverged,
and \texttt{h} will be the distance between successive \texttt{x} or
\texttt{y}-values, and so controls how fine the lattice will be.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{=} \FloatTok{1000}
\NormalTok{h }\OperatorTok{=} \FloatTok{0.005}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.005
\end{verbatim}

Why do we define these values outside of our functions, instead of just
hard-coding the values where they are needed in the function code?
Because it's much easier to tweak and change them to get the outputs
that we're looking for, all we need to do is redefine a variable, or
change the inputs to a function call, rather than rewrite and recompile
a function.

The iteration function is as simple as a \texttt{for} loop, using
\texttt{z\ =\ z\^{}2\ +\ c} to have the effect of applying the function
repeatedly. We stop the loop and return a result early if the absolute
value of \texttt{z} is ever \texttt{2} or more (we can prove that when
\texttt{abs(c)\ \textless{}\ 2}, if \texttt{abs(z)} is ever greater than
\texttt{2}, it will never be less than \texttt{2} again and will diverge
to infinity). The returned value of the function could just be
\texttt{true} or \texttt{false}, but we're actually returning the number
of the iteration if it breaks early, which we'll use to make a more
interesting visualisation.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{iterateF}\NormalTok{(z, c, n)}
    \ControlFlowTok{for}\NormalTok{ i }\OperatorTok{∈} \FloatTok{1}\OperatorTok{:}\NormalTok{n}
\NormalTok{        z }\OperatorTok{=}\NormalTok{ z}\OperatorTok{\^{}}\FloatTok{2} \OperatorTok{+}\NormalTok{ c}
        \FunctionTok{abs}\NormalTok{(z) }\OperatorTok{\textless{}} \FloatTok{2} \OperatorTok{||} \ControlFlowTok{return}\NormalTok{ i}
    \ControlFlowTok{end}
    \ControlFlowTok{return} \FloatTok{0}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
iterateF (generic function with 1 method)
\end{verbatim}

Here, we've included \texttt{n} as an input, instead of using the
variable \texttt{n} that we've defined, even though the value of
\texttt{n} will end up being given as that input. This is good practice,
as it's easier to change the inputs to a function than redefine a
variable and then rerun a function. Also, if this function was in a
different package or module, the variable \texttt{n} may not be in
scope, so it wouldn't work anyway.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Convention}, colframe=quarto-callout-tip-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

As a rule of thumb, the only variables that should be referred to within
a function are the inputs, those defined in the function, and any
\texttt{const} values that will be in scope.

\end{tcolorbox}

Naturally, we want a visual output for the Julia set, and there are
multiple ways of doing this, although all will require the use of one or
more packages. The most elegant solution uses the \texttt{Colors}
package, which includes the \texttt{RGB} type to represent colours in
the familiar \href{https://en.wikipedia.org/wiki/RGB_color_model}{RGB
format}. The package displays \texttt{RGB} types not with text, but as a
small image of that colour, and moreover a \texttt{Matrix} (i.e.~a
2-dimensional \texttt{Array}) of \texttt{RGB}s is displayed as an image
with pixels of those colours arranged as they are in the
\texttt{Matrix}. As with all packages (see Chapter~\ref{sec-packages}),
this will first need to be installed using \texttt{Pkg}, then added to
our toolkit with \texttt{using}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Colors}
\end{Highlighting}
\end{Shaded}

Now all we need is a function which can output an image. We begin by
setting up a \texttt{Matrix} of values for \texttt{z₀} (the initial
values for \texttt{z}), which we'll call \texttt{z₀s}. The
\texttt{Matrix} is constructed by array comprehension, using a range of
\texttt{x} and \texttt{y} values between \texttt{-2} and \texttt{2} (as
that is where the Julia set lies) graduated by the parameter \texttt{h}
as described above. The ordering of the indexing sets needs to be
carefully chosen so that the top left corner is \texttt{-2.0\ +\ 2.0im},
the bottom left is \texttt{-2.0\ -\ 2.0im} etc.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z₀s }\OperatorTok{=}\NormalTok{ [x₀ }\OperatorTok{+}\NormalTok{ y₀}\OperatorTok{*}\ConstantTok{im}\NormalTok{ for y₀ }\OperatorTok{∈} \FloatTok{2}\OperatorTok{:{-}}\NormalTok{h}\OperatorTok{:{-}}\FloatTok{2}\NormalTok{, x₀ }\OperatorTok{∈} \OperatorTok{{-}}\FloatTok{2}\OperatorTok{:}\NormalTok{h}\OperatorTok{:}\FloatTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

We then want to run the function \texttt{iterateF} on each of these,
which is simple enough to do by broadcasting using the \texttt{.}
syntax. Since the other inputs \texttt{c} and \texttt{n} are not
\texttt{Array}s, they will be the same for every time the function is
run with a different value of \texttt{z}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iterations }\OperatorTok{=} \FunctionTok{iterateF}\NormalTok{.(z₀s, c, n)}
\end{Highlighting}
\end{Shaded}

This gives us a new \texttt{Matrix} of values, which we want to
interpret and turn into colours. The usual way of doing this for Julia
sets is to colour the inside of the set in black, and colour the outside
of the set as a gradient, with the colour depending on how long it took
to get to \texttt{abs(z)\ \textgreater{}\ 2} and for the iteration to
stop. Hence, we chose the output to \texttt{iterateF} that we did -- the
more iterations needed, the higher the output value, but if we run out
of iterations, we return \texttt{0} to delineate a sharp boundary.

To define the gradient, we know the smallest value in the
\texttt{Matrix} \texttt{iterations} will be \texttt{0} (which will be
the black of the inside of the Julia set), but we need to know the
largest value to pin the other end of the gradient to. The \texttt{max}
function will do this, but it takes an arbitrary number of individual
numeric inputs, not a single \texttt{Array} as we currently have, so we
need to splat \texttt{iterations} to empty its values out into the
\texttt{max} function. Since it is conceptually similar to the variable
\texttt{n}, we'll overwrite that and call this new value \texttt{n} as
well (although there's no real need to).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{=} \FunctionTok{max}\NormalTok{(iterations}\OperatorTok{...}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The \texttt{RGB} constructor we'll use takes three floating-point inputs
between \texttt{0.0} and \texttt{1.0} as proportions of the maximum
amount of red, green, and blue present in the colour. By dividing each
entry of \texttt{iterations} by \texttt{n}, we'll get such a number, and
raising these to various powers will change the scale on which the
intermediate values lie, allowing us to give the gradient a coloured
tint. For instance, sending the entry \texttt{i} to
\texttt{RGB((i/n)\^{}0.5,\ (i/n)\^{}1,\ (i/n)\^{}0.5)} gives a purple
hue, as we'll see in the output below. To apply this to the whole
\texttt{Matrix}, we'll using broadcasting again, this time with the
\texttt{broadcast} function and an anonymous function to encode the
operation.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{broadcast}\NormalTok{(i }\OperatorTok{{-}\textgreater{}} \FunctionTok{RGB}\NormalTok{((i}\OperatorTok{/}\NormalTok{n)}\OperatorTok{\^{}}\FloatTok{0.5}\NormalTok{, (i}\OperatorTok{/}\NormalTok{n)}\OperatorTok{\^{}}\FloatTok{1}\NormalTok{, (i}\OperatorTok{/}\NormalTok{n)}\OperatorTok{\^{}}\FloatTok{0.5}\NormalTok{), iterations)}
\end{Highlighting}
\end{Shaded}

Putting this all together, we have the function \texttt{juliaset}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{juliaset}\NormalTok{(c, n, h)}

\NormalTok{    z₀s }\OperatorTok{=}\NormalTok{ [x₀ }\OperatorTok{+}\NormalTok{ y₀}\OperatorTok{*}\ConstantTok{im}\NormalTok{ for y₀ }\OperatorTok{∈} \FloatTok{2}\OperatorTok{:{-}}\NormalTok{h}\OperatorTok{:{-}}\FloatTok{2}\NormalTok{, x₀ }\OperatorTok{∈} \OperatorTok{{-}}\FloatTok{2}\OperatorTok{:}\NormalTok{h}\OperatorTok{:}\FloatTok{2}\NormalTok{]}

\NormalTok{    iterations }\OperatorTok{=} \FunctionTok{iterateF}\NormalTok{.(z₀s, c, n)}

\NormalTok{    n }\OperatorTok{=} \FunctionTok{max}\NormalTok{(iterations}\OperatorTok{...}\NormalTok{)}
    \ControlFlowTok{return} \FunctionTok{broadcast}\NormalTok{(i }\OperatorTok{{-}\textgreater{}} \FunctionTok{RGB}\NormalTok{((i}\OperatorTok{/}\NormalTok{n)}\OperatorTok{\^{}}\FloatTok{0.5}\NormalTok{, (i}\OperatorTok{/}\NormalTok{n)}\OperatorTok{\^{}}\FloatTok{1}\NormalTok{, (i}\OperatorTok{/}\NormalTok{n)}\OperatorTok{\^{}}\FloatTok{0.5}\NormalTok{), iterations)}
    
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
juliaset (generic function with 1 method)
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, colframe=quarto-callout-note-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Since the function \texttt{juliaset} always returns the same calculated
value, the \texttt{return} keyword is redundant here, as functions will
always return the last calculated value if no \texttt{return} is
specified. It's included only for clarity.

\end{tcolorbox}

Before we run this, we'll need another package, called
\texttt{ImageShow}. While \texttt{Colors} allows for a \texttt{Matrix}
of \texttt{RGB}s to be displayed as an image, it is limited to smaller
matrices than we're using (our value of \texttt{h} being
\texttt{H\ =\ 0.005} results in an \texttt{801} by \texttt{801}
\texttt{Matrix}). If you were to run this, it suggests installing and
using the \texttt{ImageShow} package to help with this, which is what we
will do.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{ImageShow}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-warning-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Warning}, colframe=quarto-callout-warning-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

In some environments (such as Pluto), the \texttt{ImageIO} package may
be required as well. This can be added simply by installing through
\texttt{Pkg} as usual, and then running \texttt{using\ ImageIO}.

\end{tcolorbox}

Now, we can run the function, and see what the Julia set looks like for
some different values of \texttt{c}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{juliaset}\NormalTok{(}\FloatTok{0.3531} \OperatorTok{{-}} \FloatTok{0.3165im}\NormalTok{, n, h)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{basics/arrays/arrays_files/figure-pdf/cell-104-output-1.png}

}

\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{juliaset}\NormalTok{(}\OperatorTok{{-}}\FloatTok{0.2252} \OperatorTok{+} \FloatTok{0.7049im}\NormalTok{, n, h)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{basics/arrays/arrays_files/figure-pdf/cell-105-output-1.png}

}

\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{juliaset}\NormalTok{(}\OperatorTok{{-}}\FloatTok{0.2359} \OperatorTok{{-}} \FloatTok{0.9173im}\NormalTok{, n, h)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{basics/arrays/arrays_files/figure-pdf/cell-106-output-1.png}

}

\end{figure}

\hypertarget{drawing-the-mandelbrot-set}{%
\subsection{Drawing the Mandelbrot
set}\label{drawing-the-mandelbrot-set}}

We noted earlier how similar the mathematical definitions for the filled
Julia set and the Mandelbrot set are, and indeed the same is true to
generate images of them. The only change we need to make is to start
with a \texttt{Matrix} of values of \texttt{c}, not \texttt{z}, and
change the inputs of \texttt{iterateF} accordingly. We also change the
ranges of \texttt{x} and \texttt{y} values to better frame the
Mandelbrot set, and tweak the colour function for a different shade:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{mandelbrotset}\NormalTok{(n, h)}

\NormalTok{    cs }\OperatorTok{=}\NormalTok{ [x }\OperatorTok{+}\NormalTok{ y}\OperatorTok{*}\ConstantTok{im}\NormalTok{ for y }\OperatorTok{∈} \FloatTok{1.5}\OperatorTok{:{-}}\NormalTok{h}\OperatorTok{:{-}}\FloatTok{1.5}\NormalTok{, x }\OperatorTok{∈} \OperatorTok{{-}}\FloatTok{2.5}\OperatorTok{:}\NormalTok{h}\OperatorTok{:}\FloatTok{1.5}\NormalTok{]}

\NormalTok{    iterations }\OperatorTok{=} \FunctionTok{iterateF}\NormalTok{.(}\FloatTok{0}\NormalTok{, cs, n)}

\NormalTok{    n }\OperatorTok{=} \FunctionTok{max}\NormalTok{(iterations}\OperatorTok{...}\NormalTok{)}
\NormalTok{    colours }\OperatorTok{=} \FunctionTok{broadcast}\NormalTok{(i }\OperatorTok{{-}\textgreater{}} \FunctionTok{RGB}\NormalTok{((i}\OperatorTok{/}\NormalTok{n)}\OperatorTok{\^{}}\FloatTok{0.3}\NormalTok{, (i}\OperatorTok{/}\NormalTok{n)}\OperatorTok{\^{}}\FloatTok{0.7}\NormalTok{, (i}\OperatorTok{/}\NormalTok{n)}\OperatorTok{\^{}}\FloatTok{1}\NormalTok{), iterations)}
    
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
mandelbrotset (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mandelbrotset}\NormalTok{(n, h)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{basics/arrays/arrays_files/figure-pdf/cell-108-output-1.png}

}

\end{figure}

You could, of course, go further with this. Here are some ideas that you
may wish to try:

\begin{itemize}
\item
  The Julia set has two-fold symmetry, since \(z\) and \(-z\) have the
  same result whenever they are input (as the first operation is
  squaring). Hence, to make the code (approximately) twice as efficient,
  you need only compute half of the diagram, and rotate it to get the
  other half.
\item
  Both the Julia set and the Mandelbrot set are known for their fractal
  nature, where zooming in to an area of their boundary gives similar
  complexity. Therefore, you could change the functions to accept
  different ranges of \texttt{x} and \texttt{y} values so that you could
  examine parts of the sets in closer detail.
\item
  You could change the colouring to have a more colourful gradient than
  we've done here, as can be seen in many images online. All that would
  be required for this would be a more complicated anonymous function
  (or perhaps you would prefer to write an actual function for this
  purpose).
\end{itemize}

\hypertarget{sec-readwrite}{%
\chapter{Data from and to files}\label{sec-readwrite}}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-important-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Prerequisites}, colframe=quarto-callout-important-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Before reading this chapter, you are recommended to have read
Chapter~\ref{sec-fundamentals}

\end{tcolorbox}

\begin{itemize}
\item
  stdin and stdout examples
\item
  Opening file from path
\item
  CSV.jl?
\end{itemize}

\hypertarget{sec-plotting}{%
\chapter{\texorpdfstring{Plotting outputs with
\texttt{Plots.jl}}{Plotting outputs with Plots.jl}}\label{sec-plotting}}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-important-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Prerequisites}, colframe=quarto-callout-important-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Before reading this chapter, you are recommended to have read
Chapter~\ref{sec-fundamentals}, Chapter~\ref{sec-packages}

\end{tcolorbox}

\hypertarget{sec-testing}{%
\chapter{Testing, debugging, and fixing code}\label{sec-testing}}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacitybacktitle=0.6, leftrule=.75mm, breakable, coltitle=black, bottomrule=.15mm, colbacktitle=quarto-callout-important-color!10!white, bottomtitle=1mm, rightrule=.15mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Prerequisites}, colframe=quarto-callout-important-color-frame, left=2mm, colback=white, opacityback=0, arc=.35mm, toptitle=1mm, titlerule=0mm]

Before reading this chapter, you are recommended to have read
Chapter~\ref{sec-fundamentals}

\end{tcolorbox}

\bookmarksetup{startatroot}

\hypertarget{references}{%
\chapter*{References}\label{references}}
\addcontentsline{toc}{chapter}{References}

\markboth{References}{References}

\hypertarget{refs}{}
\begin{CSLReferences}{0}{0}
\end{CSLReferences}

docs.julialang.org github.com/julialang/julia



\end{document}
